
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <title>Yocto/GL</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
      <link rel="stylesheet" href="style.css">
    </head>
    <body>
    <header>
        <!-- a href="index.html">about</a -->
        <!-- a href="yocto_gl.html">api</a -->
        <!-- a href="https://github.com/xelatihy/yocto-gl">github</a -->
        <p><a href="index.html">Yocto/GL</a> <a href="https://github.com/xelatihy/yocto-gl"><img alt="" src="images/github-logo.png"></a> + <a href="https://twitter.com/intent/tweet?text=Check%20out&amp;url=https%3A%2F%2Fgoo.gl%2FYvQvBr&amp;hashtags=yocto-gl&amp;via=xelatihy"><img alt="" src="images/twitter-logo.png"></a></p>
<ul>
<li><a href="#toc0">About</a></li>
<li><a href="#toc1">Credits</a></li>
<li><a href="#toc2">Design Considerations</a></li>
<li><a href="#toc3">Compilation</a></li>
<li><a href="#toc4">Example Applications</a></li>
<li><a href="#toc5">Usage</a><ul>
<li><a href="#toc6"> Small Vectors and Matrices, Frames, Bounding Boxes and Transforms</a></li>
<li><a href="#toc7"> Random Number Generation, Noise, Hashing and Monte Carlo support</a></li>
<li><a href="#toc8"> Shape Utilities</a></li>
<li><a href="#toc9"> Animation utilities</a></li>
<li><a href="#toc10"> Image and color</a></li>
<li><a href="#toc11"> Ray Intersection and Point Overlap Queries</a></li>
<li><a href="#toc12"> Simple scene</a></li>
<li><a href="#toc13"> Pathtracing</a></li>
<li><a href="#toc14"> Wavefront OBJ</a></li>
<li><a href="#toc15"> Khronos glTF</a></li>
<li><a href="#toc16"> OpenGL support</a></li>
<li><a href="#toc17"> Other Utilities</a></li>
<li><a href="#toc18"> Command Line Parsing</a></li>
</ul>
</li>
<li><a href="#toc19">History</a></li>
<li><a href="#toc20">API Documentation</a><ul>
<li><a href="#toc21"> Basic math constants and functions</a></li>
<li><a href="#toc22"> Fixed-size vectors</a></li>
<li><a href="#toc23"> Fixed-size matrices</a></li>
<li><a href="#toc24"> Rigid-body frames</a></li>
<li><a href="#toc25"> Quaternions</a></li>
<li><a href="#toc26"> Axis-aligned bounding boxes</a></li>
<li><a href="#toc27"> Primitive bounding boxes</a></li>
<li><a href="#toc28"> Rays</a></li>
<li><a href="#toc29"> Transforms</a></li>
<li><a href="#toc30"> User interface utilities</a></li>
<li><a href="#toc31"> Random number generation</a></li>
<li><a href="#toc32"> Monte Carlo sampling</a></li>
<li><a href="#toc33"> Hashing</a></li>
<li><a href="#toc34"> Perlin noise</a></li>
<li><a href="#toc35"> Python-like iterators</a></li>
<li><a href="#toc36"> Container operations</a></li>
<li><a href="#toc37"> Geometry utilities</a></li>
<li><a href="#toc38"> Animation utilities</a></li>
<li><a href="#toc39"> Shape utilities</a></li>
<li><a href="#toc40"> Shape sampling</a></li>
<li><a href="#toc41"> Example shapes</a></li>
<li><a href="#toc42"> Image containers</a></li>
<li><a href="#toc43"> Image operations</a></li>
<li><a href="#toc44"> Example images</a></li>
<li><a href="#toc45"> Image loading and saving</a></li>
<li><a href="#toc46"> Ray-primitive intersection</a></li>
<li><a href="#toc47"> Point-primitive overlap</a></li>
<li><a href="#toc48"> Bounding volume hierarchy</a></li>
<li><a href="#toc49"> Simple scene</a></li>
<li><a href="#toc50"> Example scenes</a></li>
<li><a href="#toc51"> Path-tracing support</a></li>
<li><a href="#toc52"> Path tracing</a></li>
<li><a href="#toc53"> Wavefront OBJ</a></li>
<li><a href="#toc54"> Khronos glTF</a></li>
<li><a href="#toc55"> Svg</a></li>
<li><a href="#toc56"> String, path and file functions</a></li>
<li><a href="#toc57"> File loading and saving</a></li>
<li><a href="#toc58"> Immediate-mode command line parser</a></li>
<li><a href="#toc59"> Simple logging</a></li>
<li><a href="#toc60"> Simple timer</a></li>
<li><a href="#toc61"> OpenGL objects and utilities</a></li>
<li><a href="#toc62"> OpenGL default shaders</a></li>
<li><a href="#toc63"> OpenGL window</a></li>
<li><a href="#toc64"> OpenGL widgets</a></li>
</ul>
</li>
<li><a href="yocto_gl.html#api">API Documentation</a></li>
</ul>
    </header>
    <article>
    <p><a id="toc0"></a></p>
<h1>Yocto/GL: Tiny C++ Library for Physically-based Graphics</h1>
<p>Yocto/GL is a collection utilities for building physically-based graphics
algorithms implemented as a two-file library (<code>yocto_gl.h</code>, <code>yocto_gl.cpp</code>),
and released under the MIT license. Features include:</p>
<ul>
<li>convenience math functions for graphics</li>
<li>static length vectors for 2, 3, 4 length of arbitrary type</li>
<li>static length matrices for 2x2, 3x3, 4x4 of arbitrary type</li>
<li>static length rigid transforms (frames), specialized for 2d and 3d space</li>
<li>linear algebra operations and transforms</li>
<li>axis aligned bounding boxes</li>
<li>rays and ray-primitive intersection</li>
<li>point-primitive distance and overlap tests</li>
<li>normal and tangent computation for meshes and lines</li>
<li>generation of tesselated meshes</li>
<li>mesh refinement with linear tesselation and Catmull-Cark subdivision</li>
<li>keyframed animation, skinning and morphing</li>
<li>random number generation via PCG32</li>
<li>simple image data structure and a few image operations</li>
<li>simple scene format</li>
<li>generation of image examples</li>
<li>generation of scene examples</li>
<li>procedural sun and sky HDR</li>
<li>procedural Perlin noise</li>
<li>BVH for intersection and closest point query</li>
<li>Python-like string, path and container operations</li>
<li>utilities to load and save entire text and binary files</li>
<li>immediate mode command line parser</li>
<li>simple logger</li>
<li>path tracer supporting surfaces and hairs, GGX and MIS</li>
<li>support for loading and saving Wavefront OBJ and Khronos glTF</li>
<li>support for loading Bezier curves from SVG</li>
<li>OpenGL utilities to manage textures, buffers and prograrms</li>
<li>OpenGL shader for image viewing and GGX microfacet and hair rendering</li>
</ul>
<p>The current version is 0.1.0. You can access the previous multi-file version
with tag "v0.0.1" in this repository.</p>
<p><a id="toc1"></a></p>
<h2>Credits</h2>
<p>This library includes code from the PCG random number generator,
boost hash_combine, Pixar multijittered sampling,
code from "Real-Time Collision Detection" by Christer Ericson, base64
encode/decode by Ren√© Nyffenegger and public domain code from
github.com/sgorsten/linalg, gist.github.com/badboy/6267743 and
github.com/nothings/stb_perlin.h.</p>
<p>This library imports many symbols from std for three reasons: avoid
verbosity , ensuring better conventions when calling math functions and
allowing easy overriding of std containers if desired. Just do not
flatten this namespace into yours if this is a concern.</p>
<p>For most components of the library, the use should be relatively easy to
understand if you are familiar with 3d computer graphics. For more complex
components, we follow the usage below.</p>
<p><a id="toc2"></a></p>
<h2>Design Considerations</h2>
<p>Yocto/GL tries to follow a simple programming model inspired by C but with
heavy use of operator overloading for math readability. We attempt to make
the code easy to use use rather than as performant as possible.
We adopt a functional style and only rarely use classes and methods.
Using a function style makes the code easier to extend, more explicit in
the function requirements, and easier to write parallel-friendly APIs.
I guess you could call this "data-driven programming".</p>
<p>The use of templates in Yocto was the reason for many refactorings, going
from no template to heavy templates use. At this time, templates are used
in the basic types to make the codebase shorter and reduce bugs,
at the price of accessibility for beginners. The truth is that modern C++,
a tenant of Yocto, is heavily templated anyway, so being able to read
template code is necessary no matter how Yocto does things.</p>
<p>We make use of exception for error reporting. This makes the code
much cleaner and more in line with the expectation of most other programming
languages.</p>
<p>Finally, we often import symbols from the standard library rather than
using the <code>std::name</code> pattern. We found that this improves consistency
when using math functions, and is more readable with templates. We realize
this is not standard, but the imports are hidden within the ygl namespace,
so library users do not have to be concern about it.</p>
<p><a id="toc3"></a></p>
<h2>Compilation</h2>
<p>Yocto/GL is written in C++14 and compiles on OSX (clang from Xcode 9+),
Linux (gcc 6+, clang 4+) and Windows (MSVC 2015, MSVC 2017).</p>
<p>For image loading and saving, Yocto/GL depends on <code>stb_image.h</code>,
<code>stb_image_write.h</code>, <code>stb_image_resize.h</code> and <code>tinyexr.h</code>. These features
can be disabled by defining YGL_IMAGEIO to 0 before including this file.
If these features are useful, then the implementation files need to
included in the manner described by the respective libraries. To simplify
builds, we provide a file that builds these libraries, <code>stb_image.cpp</code>.</p>
<p>To support Khronos glTF, Yocto/GL depends on <code>json.hpp</code>. This feature can
be disabled by defining YGL_GLTF to 0 before including this file.</p>
<p>To support SVG, Yocto/GL depends on <code>nanosvg.h</code>. This feature can
be disabled by defining YGL_SVG to 0 before including this file.</p>
<p>OpenGL utilities include the OpenGL libraries, use GLEW on Windows/Linux,
GLFW for windows handling and Dear ImGui for UI support.
Since OpenGL is quite onerous and hard to link, its support can be disabled
by defining YGL_OPENGL to 1 before including this file. If you use any of
the OpenGL calls, make sure to properly link to the OpenGL libraries on
your system. For ImGUI, build with the libraries <code>imgui.cpp</code>,
<code>imgui_draw.cpp</code>, <code>imgui_impl_glfw_gl3.cpp</code>.</p>
<p><a id="toc4"></a></p>
<h2>Example Applications</h2>
<p>You can see Yocto/GL in action in the following applications written to
test the library:</p>
<ul>
<li><code>yview.cpp</code>: simple OpenGL viewer for OBJ and glTF scenes</li>
<li><code>ytrace.cpp</code>: offline path-tracer</li>
<li><code>yitrace.cpp.cpp</code>: interactive path-tracer</li>
<li><code>yscnproc.cpp</code>: scene manipulation and conversion to/from OBJ and glTF</li>
<li><code>ytestgen.cpp</code>: creates test cases for the path tracer and GL viewer</li>
<li><code>yimview.cpp</code>: HDR/PNG/JPG image viewer with exposure/gamma tone mapping</li>
<li><code>yimproc.cpp</code>: offline image manipulation.</li>
</ul>
<p>You can build the example applications using CMake with
    <code>mkdir build; cd build; cmake ..; cmake --build</code></p>
<p>Here are two images rendered with the builtin path tracer, where the
scenes are crated with the test generator.</p>
<figure><img alt="Yocto/GL" src="images/shapes.png"></figure>
<figure><img alt="Yocto/GL" src="images/lines.png"></figure>
<p><a id="toc5"></a></p>
<h2>Usage</h2>
<p>To use the library simply include this file and setup the compilation
option as described above.
All library features are documented at their definition and should be
relatively easy to use if you are familiar with writing graphics code.
You can find the extracted documentation at <code>yocto_gl.html</code>.
Here we give an overview of some of the main features.</p>
<p><a id="toc6"></a></p>
<h3>Small Vectors and Matrices, Frames, Bounding Boxes and Transforms</h3>
<p>We provide common operations for small vectors and matrices typically used
in graphics. In particular, we support 2-4 dimensional vectors of arbitrary
<code>vec&lt;T, 2&gt;</code>, <code>vec&lt;T, 3&gt;</code>, <code>vec&lt;T, 4&gt;</code> with specializarion for float
(<code>vec2f</code>, <code>vec3f</code>, <code>vec4f</code>), int (<code>vec2i</code>, <code>vec3i</code>, <code>vec4i</code>) and bytes
(<code>vec4b</code>). Vector operations are templated so they work on every type, but
many of them are well-defined only for float types.</p>
<p>We support 2-4 dimensional generic matrices <code>mat&lt;T, 2&gt;</code>, <code>mat&lt;T, 3&gt;</code>,
<code>mat&lt;T, 4&gt;</code>, with matrix-matrix and matrix-vector products, transposes and
inverses. Matrices are stored in column-major ordered and are accessed and
constructed by column.</p>
<p>To represent transformations, most of the library facilities prefer the use
coordinate frames, aka rigid transforms, represented as <code>frame&lt;T, 3&gt;</code>.
The structure store three coordinate axis and the frame origin. This is
equivalent to a rigid transform written as a column-major affine
matrix. Transform operations are better behaved with this representation.</p>
<p>We represent coordinate bounds with axis-aligned bounding boxes in 1-4
dimensions: <code>bbox&lt;T, 1&gt;</code>, <code>bbox&lt;T, 2&gt;</code>, <code>bbox&lt;T, 3&gt;</code>, <code>bbox&lt;T, 4&gt;</code>. These
types support expansion operation, union and containment. We provide
operations to compute bounds for points, lines, triangles and quads.</p>
<p>For all basic types we support iteration with <code>begin()</code>/<code>end()</code> pairs,
data access with <code>data()</code>, <code>empty()</code> and <code>size()</code> and stream inout and
output.</p>
<p>For both matrices and frames we support transform operations for points,
vectors and directions (<code>trasform_point()</code>, <code>trasform_vector()</code>,
<code>trasform_direction()</code>). For frames we also the support inverse operations
(<code>transform_xxx_inverse()</code>). Transform matrices and frames can be
constructed from basic translation, rotation and scaling, e.g. with
<code>translation_mat4f()</code> or <code>translation_frame3f()</code> respectively, etc. For
rotation we support axis-angle and quaternions, with slerp.</p>
<p><a id="toc7"></a></p>
<h3>Random Number Generation, Noise, Hashing and Monte Carlo support</h3>
<p>This library supports many facilities helpful in writing sampling
functions targeting path tracing and shape generations.</p>
<ol>
<li>Random number generation with PCG32:<ol>
<li>initialize the random number generator with <code>init_rng()</code></li>
<li>advance the random number state with <code>advance_rng()</code></li>
<li>if necessary, you can reseed the rng with <code>seed_rng()</code></li>
<li>generate random integers in an interval with <code>next_rand1i()</code></li>
<li>generate random floats and double in the [0,1) range with
   <code>next_rand1f()</code>, <code>next_rand2f()</code>, <code>next_rand3f()</code>, <code>next_rand1d()</code></li>
<li>you can skip random numbers with <code>advance_rng()</code> and get the skipped
   length with <code>rng_distance()</code></li>
<li>generate random shuffled sequences with <code>rng_shuffle()</code></li>
</ol>
</li>
<li>Perlin noise: <code>perlin_noise()</code> to generate Perlin noise with optional
   wrapping, with fractal variations <code>perlin_ridge_noise()</code>,
   <code>perlin_fbm_noise()</code>, <code>perlin_turbulence_noise()</code></li>
<li>Integer hashing: public domain hash functions for integer values as
   <code>hash_permute()</code>, <code>hash_uint32()</code>, <code>hash_uint64()</code>, <code>hash_uint64_32()</code>
   and <code>hash_combine()</code>.</li>
<li>Monte Carlo support: warp functions from [0,1)^k domains to domains
   commonly used in path tracing. In particular, use <code>sample_hemisphere()</code>,
   <code>sample_sphere()</code>, <code>sample_hemisphere_cosine()</code>,
   <code>sample_hemisphere_cospower()</code>. <code>sample_disk()</code>. <code>sample_cylinder()</code>.
   <code>sample_triangle()</code>. For each warp, you can compute the PDF with
   <code>sample_xxx_pdf()</code>.</li>
</ol>
<p><a id="toc8"></a></p>
<h3>Shape Utilities</h3>
<p>The library contains a few function to help with typically geometry
manipulation useful to support scene viewing and path tracing.</p>
<ol>
<li>compute line tangents, and triangle and quad areas and normals</li>
<li>interpolate values over primitives with <code>eval_line()</code>,
   <code>eval_triangle()</code> and <code>eval_quad()</code></li>
<li>evaluate Bezier curves and derivatives with <code>eval_bezier()</code> and
   <code>eval_bezier_derivative()</code></li>
<li>compute smooth normals and tangents with <code>compute_normals()</code>
/  <code>compute_tangents()</code></li>
<li>compute tangent frames from texture coordinates with
   <code>compute_tangent_space()</code></li>
<li>compute skinning with <code>compute_skinning()</code> and
   <code>compute_matrix_skinning()</code></li>
<li>create shapes with <code>make_points()</code>, <code>make_lines()</code>, <code>make_uvgrid()</code></li>
<li>merge element with <code>marge_lines()</code>, <code>marge_triangles()</code>, <code>marge_quads()</code></li>
<li>facet elements with <code>facet_lines()</code>, <code>facet_triangles()</code>, <code>facet_quads()</code></li>
<li>shape sampling with <code>sample_points()</code>, <code>sample_lines()</code>,
   <code>sample_triangles()</code>; initialize the sampling CDFs with
   <code>sample_points_cdf()</code>, <code>sample_lines_cdf()</code>, <code>sample_triangles_cdf()</code></li>
<li>samnple a could of point over a surface with <code>sample_triangles_points()</code></li>
<li>get edges and boundaries with <code>get_edges()</code></li>
<li>convert quads to triangles with <code>convert_quads_to_triangles()</code></li>
<li>convert face varying to vertex shared representations with
    <code>convert_face_varying()</code></li>
<li>subdivide elements by edge splits with <code>subdivide_lines()</code>,
    <code>subdivide_triangles()</code>, <code>subdivide_quads()</code>, <code>subdivide_beziers()</code></li>
<li>Catmull-Clark subdivision surface with <code>subdivide_catmullclark()</code></li>
<li>example shapes: <code>make_cube()</code>, <code>make_uvsphere()</code>, <code>make_uvhemisphere()</code>,
    <code>make_uvquad()</code>, <code>make_uvcube()</code>, <code>make_fvcube()</code>, <code>make_hair()</code>,
    <code>make_suzanne()</code></li>
</ol>
<p><a id="toc9"></a></p>
<h3>Animation utilities</h3>
<p>The library contains a few function to help with typical animation
manipulation useful to support scene viewing.</p>
<ol>
<li>evaluate keyframed values with step, linear and bezier interpolation with
   <code>eval_keyframed_step()</code>, <code>eval_keyframed_linear()</code>,
   <code>eval_keyframed_bezier()</code></li>
<li>mesh skinning with <code>compute_matrix_skinning()</code></li>
</ol>
<p><a id="toc10"></a></p>
<h3>Image and color</h3>
<p>Images are stored with the <code>image</code> templated structure. The two most used
image types are 4-byte per pixel sRGB images <code>image4b</code>, or 4-float per
pixel HDR images <code>image4f</code>.</p>
<ol>
<li>convert between byte and float images with <code>srgb_to_linear()</code> and
   <code>linear_to_srgb()</code></li>
<li>color conversion with <code>hsv_to_rgb()</code>, <code>xyz_to_rgb()</code> and <code>rgb_to_xyz()</code></li>
<li>exposure-gamma tonemapping, with optional filmic curve, with
   <code>tonemap_image()</code></li>
<li>compositing support with <code>image_over()</code></li>
<li>example image generation with <code>m,ake_grid_image()</code>,
   <code>make_checker_image()</code>, <code>make_bumpdimple_image()</code>, <code>make_ramp_image()</code>,
   <code>make_gammaramp_image()</code>, <code>make_gammaramp_imagef()</code>, <code>make_uv_image()</code>,
   <code>make_uvgrid_image()</code>, <code>make_recuvgrid_image()</code></li>
<li>bump to normal mapping with <code>bump_to_normal_map()</code></li>
<li>HDR sun-sky with <code>m ake_sunsky_image()</code></li>
<li>various noise images with <code>make_noise_image()</code>, <code>make_fbm_image()</code>,
   <code>make_ridge_image()</code>, <code>make_turbulence_image()</code></li>
<li>image loading and saving with <code>load_image4b()</code>, <code>load_image4f()</code>,
   <code>save_image4b()</code>, <code>save_image4f()</code></li>
<li>image resizing with <code>resize_image()</code></li>
</ol>
<p><a id="toc11"></a></p>
<h3>Ray Intersection and Point Overlap Queries</h3>
<p>We support ray-scene intersection for points, lines and triangles
accelerated by a simple BVH data structure.  Our BVH is written for minimal
code and not maximum speed, but still gives reasonable results. We suggest
the use of Intel's Embree as a fast alternative.</p>
<ol>
<li>use <code>ray3f</code> to represent rays</li>
<li>build the BVH with <code>build_points_bvh()</code>, <code>build_points_bvh()</code> or
  <code>build_points_bvh()</code></li>
<li>perform ray-element intersection with <code>intersect_points_bvh()</code>,
  <code>intersect_lines_bvh()</code> and <code>intersect_triangles_bvh()</code></li>
<li>perform point overlap queries with <code>overlap_points_bvh()</code>,
  <code>overlap_lines_bvh()</code> and <code>overlap_triangles_bvh()</code></li>
<li>to support custom elements, use <code>buid_bvh()</code>, <code>intersect_bvh()</code> and
  <code>overlap_bvh()</code> and provide them with proper callbacks</li>
<li>we also experimentally support quads with the <code>xxx_quads_xxx()</code> functions</li>
</ol>
<p><a id="toc12"></a></p>
<h3>Simple scene</h3>
<p>We support a simple scene model used to quickly write demos that lets you
load/save Wavefront OBJ and Khronos glTF and perform several simple scene
manipulation including ray-scene intersection and closest point queries.</p>
<p>The geometry model is comprised of a set of shapes, which are indexed
collections of points, lines, triangles and quads. Each shape may contain
only one element type. Shapes are organized into a scene by creating shape
instances, each its own transform. Materials are specified like in glTF and
include emission, base-metallic and diffuse-specular parametrization,
normal, occlusion and displacement mapping. Finally, the scene containers
cameras and environment maps. Quad support in shapes is experimental and
mostly supported for loading and saving.</p>
<p>For low-level access to OBJ/glTF formats, you are best accessing the formats
directly with Yocto/Obj and Yocto/glTF. This components provides a
simplified high-level access to each format which is sufficient for most
applications and tuned for quick creating viewers, renderers and simulators.</p>
<ol>
<li>load a scene with <code>load_scene()</code> and save it with <code>save_scene()</code>.</li>
<li>add missing data with <code>add_elements()</code></li>
<li>use <code>compute_bounds()</code> to compute element bounds</li>
<li>can merge scene together with <code>merge_into()</code></li>
<li>make example scenes with <code>make_test_scene()</code></li>
</ol>
<p>Ray-intersection and closet-point routines supporting points,
lines and triangles accelerated by a two-level bounding volume
hierarchy (BVH). Quad support is experimental.</p>
<ol>
<li>build the bvh with <code>make_bvh()</code></li>
<li>perform ray-interseciton tests with <code>intersect_ray()</code><ul>
<li>use early_exit=false if you want to know the closest hit point</li>
<li>use early_exit=false if you only need to know whether there is a hit</li>
<li>for points and lines, a radius is required</li>
<li>for triangles, the radius is ignored</li>
</ul>
</li>
<li>perform point overlap tests with <code>overlap_point()</code> to check whether
   a point overlaps with an element within a maximum distance<ul>
<li>use early_exit as above</li>
<li>for all primitives, a radius is used if defined, but should
  be very small compared to the size of the primitive since the radius
  overlap is approximate</li>
</ul>
</li>
<li>perform instance overlap queries with <code>overlap_instance_bounds()</code></li>
<li>use <code>refit_bvh()</code> to recompute the bvh bounds if transforms or vertices
   are changed (you should rebuild the bvh for large changes)</li>
</ol>
<p>Notes: Quads are internally handled as a pair of two triangles v0,v1,v3 and
v2,v3,v1, with the u/v coordinates of the second triangle corrected as 1-u
and 1-v to produce a quad parametrization where u and v go from 0 to 1. This
is equivalent to Intel's Embree.</p>
<p><a id="toc13"></a></p>
<h3>Pathtracing</h3>
<p>We supply a path tracer implementation with support for textured mesh
lights, GGX/Phong materials, environment mapping. The interface supports
progressive parallel execution. The path tracer takes as input a scene
and update pixels in image with traced samples. We use a straightfoward
path tracer with MIS and also a few simpler shaders for debugging or
quick image generation.</p>
<p>Materials are represented as sums of an emission term, a diffuse term and
a specular microfacet term (GGX or Phong). Only opaque for now. We pick
a proper material type for each shape element type (points, lines,
triangles).</p>
<p>Lights are defined as any shape with a material emission term. Additionally
one can also add environment maps. But even if you can, you might want to
add a large triangle mesh with inward normals instead. The latter is more
general (you can even more an arbitrary shape sun). For now only the first
env is used.</p>
<ol>
<li>build the ray-tracing acceleration structure with <code>make_bvh()</code></li>
<li>prepare lights for rendering <code>update_lights()</code></li>
<li>define rendering params with the <code>trace_params</code> structure</li>
<li>render blocks of samples with <code>trace_block()</code></li>
</ol>
<p>The code can also run in fully asynchronous mode to preview images in a
window.</p>
<ol>
<li>build the ray-tracing acceleration structure with <code>make_bvh()</code></li>
<li>prepare lights for rendering <code>update_lights()</code></li>
<li>define rendering params with the <code>trace_params</code> structure</li>
<li>initialize the progressive rendering buffers</li>
<li>start the progressive renderer with <code>trace_async_start()</code></li>
<li>stop the progressive renderer with <code>trace_async_stop()</code></li>
</ol>
<p><a id="toc14"></a></p>
<h3>Wavefront OBJ</h3>
<p>Wavefront OBJ/MTL loader and writer with support for points,
lines, triangles and general polygons and all materials properties.
Contains also a few extensions to easily create demos such as per-vertex
color and radius, cameras, environment maps and instances.
Can use either a low-level OBJ representation, from this files,
or a high level flattened representation included in Yocto/Scn.</p>
<p>Both in reading and writing, OBJ has no clear convention on the orientation
of textures Y axis. So in many cases textures appears flipped. To handle
that, use the option to flip textures coordinates on either saving or
loading. By default texture coordinates are flipped since this seems
the convention found on test cases collected on the web. The value Tr
has similar problems, since its relation to opacity is software specific.
Again we let the user chose the conversion and set the default to the
one found on the web.</p>
<p>In the high level interface, shapes are indexed meshes and are described
by arrays of vertex indices for points/lines/triangles and arrays for vertex
positions, normals, texcoords, color and radius. The latter two as
extensions. Since OBJ is a complex formats that does not match well with
current GPU rendering / path tracing algorithms, we adopt a simplification
similar to other single file libraries:
1. vertex indices are unique, as in OpenGL and al standard indexed triangle
  meshes data structures, and not OBJ triplets; YOCTO_OBJ ensures that no
  vertex duplication happens thought for same triplets
2. we split shapes on changes to groups and materials, instead of keeping
  per-face group/material data; this makes the data usable right away in
  a GPU viewer; this is not a major limitation if we accept the previous
  point that already changes shapes topology.</p>
<ol>
<li>load a obj data with <code>load_obj()</code>; can load also textues</li>
<li>look at the <code>obj_XXX</code> data structures for access to individual elements</li>
<li>use obj back to disk with <code>save_obj()</code>; can also save textures</li>
<li>use get_shape() to get a flattened shape version that contains only
   triangles, lines or points</li>
</ol>
<p><a id="toc15"></a></p>
<h3>Khronos glTF</h3>
<p>Khronos GLTF loader and writer for Khronos glTF format. Supports
all the glTF spec and the Khronos extensions. All parsing and writing code
is autogenerated form the schema. Supports glTF version 2.0 and the
following extensions: <code>KHR_binary_glTF</code> and <code>KHR_specular_glossiness</code>.</p>
<p>This component depends on <code>json.hpp</code> and, for image loading and saving,
it depends on <code>stb_image.h</code>, <code>stb_image_write.h</code>, <code>stb_image_resize.h</code> and
<code>tinyexr.h</code>. This feature can be disabled as before.</p>
<p>The library provides a low  level interface that is a direct
C++ translation of the glTF schemas and should be used if one wants
complete control over the format or an application wants to have their
own scene code added. A higher-level interface is provided by the scene
or by <code>yocto_gltf.h</code>.</p>
<p>glTF is a very complex file format and was designed mainly with untyped
languages in mind. We attempt to match the glTF low-level interface
to C++ as best as it can. Since the code is generated from the schema, we
follow glTF naming conventions and typing quite well. To simplify adoption
and keep the API relatively simple we use vector as arrays and use
pointers to reference to all glTF objects. While this makes it less
efficient than it might have been, glTF heavy use of optional values makes
this necessary. At the same time, we do not keep track of set/unset values
for basic types (int, float, bool) as a compromise for efficiency.</p>
<p>glTF uses integer indices to access objects.
While writing code ourselves we found that we add significant problems
since we would use an index to access the wrong type of scene objects.
For this reasons, we use an explicit index <code>glTFid&lt;T&gt;</code> that can only access
an object of type T. Internally this is just the same old glTF index. But
this can used to access the scene data with <code>glTF::get&lt;T&gt;(index)</code>.</p>
<ol>
<li>load a glTF model with <code>load_gltf()</code></li>
<li>look at the <code>glTFXXX</code> data structures for access to individual elements</li>
<li>save glTF back to disk with <code>save_gltf()</code></li>
</ol>
<p><a id="toc16"></a></p>
<h3>OpenGL support</h3>
<p>We include a set of utilities to draw on screen with OpenGL 3.3, manage
windows with GLFW and draw immediate-mode widgets with ImGui.</p>
<ol>
<li>texture and buffer objects with <code>gl_texture</code> and <code>gl_buffer</code><ul>
<li>create textures/buffers with appropriate constructors</li>
<li>check validity with <code>is_valid()</code></li>
<li>update textures/buffers with <code>update()</code> functions</li>
<li>delete textures/buffers with <code>clear()</code></li>
<li>bind/unbind textures/buffers with <code>bind()</code>/<code>unbind()</code></li>
<li>draw elements with <code>gl_buffer::draw_elems()</code></li>
</ul>
</li>
<li>program objects with <code>gl_program</code><ul>
<li>program creation with constructor</li>
<li>check validity with <code>is_valid()</code></li>
<li>delete with <code>clear()</code></li>
<li>uniforms with <code>set_program_uniform()</code></li>
<li>vertex attrib with <code>set_program_vertattr()</code></li>
<li>draw elements with <code>gl_buffer::draw_elems()</code></li>
</ul>
</li>
<li>image viewing with <code>gl_stdimage_program</code>, with support for tone mapping.</li>
<li>draw surfaces and hair with GGX/Kayjia-Kay with <code>gl_stdsurface_program</code><ul>
<li>initialize the program with constructor</li>
<li>check validity with <code>is_valid()</code></li>
<li>start/end each frame with <code>begin_frame()</code>, <code>end_frame()</code></li>
<li>define lights with <code>set_lights()</code></li>
<li>start/end each shape with <code>begin_shape()</code>, <code>end_shape()</code></li>
<li>define material Parameters with <code>set_material()</code></li>
<li>define vertices with <code>set_vert()</code></li>
<li>draw elements with <code>draw_elems()</code></li>
</ul>
</li>
<li>draw yocto scenes using the above shader<ul>
<li>initialize the rendering state with <code>init_stdsurface_state()</code></li>
<li>load/update meshes and textures with <code>update_stdsurface_state()</code></li>
<li>setup draw params using a <code>gl_stdsurface_params</code> struct</li>
<li>draw scene with <code>draw_stdsurface_scene()</code></li>
</ul>
</li>
<li>also includes other utlities for quick OpenGL hacking</li>
<li>GLFW window with <code>gl_window</code><ul>
<li>create with constructor</li>
<li>delete with <code>clear()</code></li>
<li>set callbacks with <code>set_callbacks()</code></li>
<li>includes carious utilities to query window, mouse and keyboard</li>
</ul>
</li>
<li>immediate mode widgets using ImGui<ul>
<li>init with <code>init_widget()</code></li>
<li>use the various widget calls to draw the widget and handle events</li>
</ul>
</li>
</ol>
<p><a id="toc17"></a></p>
<h3>Other Utilities</h3>
<p>We include additional utilities for writing command line applications and
manipulating files.</p>
<ol>
<li>Python-like string operations: <code>startswith()</code>, <code>endswith()</code>,
<code>contains()</code>,
   <code>splitlines()</code>, <code>partition()</code>, <code>split()</code>, <code>splitlines()</code>, <code>strip()</code>,
   <code>rstrip()</code>, <code>lstrip()</code>, <code>join()</code>, <code>lower()</code>, <code>upper()</code>, <code>isspace()</code>,
   <code>replace()</code></li>
<li>Path-like path operations: <code>path_dirname()</code>, <code>path_extension()</code>,
   <code>path_basename()</code>, <code>path_filename()</code>, <code>replace_path_extension()</code>,
   <code>prepend_path_extension()</code>, <code>split_path()</code></li>
<li>Python-like format strings (only support for position arguments and no
   formatting commands): <code>format()</code>, <code>print()</code></li>
<li>load/save entire files: <code>load_binary()</code>, <code>load_text()</code>,
   <code>save_text()</code> and <code>save_binary()</code></li>
<li>simple logger with support for console and file streams:<ol>
<li>create a <code>logger</code></li>
<li>add more streams with <code>add_console_stream()</code> or <code>add_file_stream()</code></li>
<li>write log messages with <code>log_msg()</code> and its variants</li>
<li>you can also use a global default logger with the free functions
   <code>log_XXX()</code></li>
</ol>
</li>
<li>timer for simple access to <code>std::chrono</code>:<ol>
<li>create a <code>timer</code></li>
<li>start and stop the clock with <code>start()</code> and <code>stop()</code></li>
<li>get time with <code>elapsed_time()</code></li>
</ol>
</li>
</ol>
<p><a id="toc18"></a></p>
<h3>Command Line Parsing</h3>
<p>The library includes a simple command line parser that parses commands in
immediate mode, i.e. when an option is declared. The parser supports options
and unnamed arguments with generic types parsed using C++ stream. The
parser autogenerates its own documentation. This allows to write complex
command lines with a tiny amount of implementation code on both the library
and user end.</p>
<ol>
<li>create a <code>cmdline</code> parser object by passing <code>argc, argv, name, help</code><ul>
<li>an option for printing help is automatically added</li>
</ul>
</li>
<li>for each option, parse it calling the functions <code>parse_opt()</code><ul>
<li>options are parsed on the fly and a comprehensive help is
  automatically generated</li>
<li>supports bool (flags), int, float, double, string, enums</li>
<li>options names are "--longname" for longname and "-s" for short</li>
<li>command line format is "--longname value", "-s v" for all but flags</li>
<li>values are parsed with <code>iostream &lt;&lt;</code> operators</li>
<li>for general use <code>opt = parse_opt&lt;type&gt;()</code></li>
<li>for boolean flags is <code>parse_flag()</code></li>
<li>for enums use <code>parse_opte()</code></li>
</ul>
</li>
<li>for each unnamed argument, parse it calling the functions parse_arg()<ul>
<li>names are only used for help</li>
<li>supports types as above</li>
<li>for general use <code>arg = parse_arg&lt;type&gt;()</code></li>
<li>to parse all remaining values use <code>args = parse_arga&lt;type&gt;(...)</code></li>
</ul>
</li>
<li>end cmdline parsing with <code>check_parsing()</code> to check for unused values,
   missing arguments</li>
<li>to check for error use <code>should_exit()</code> and to print the message use
   <code>get_message()</code></li>
<li>since arguments are parsed immediately, one can easily implement
   subcommands by just branching the command line code based on a read
   argument without any need for complex syntax</li>
</ol>
<p><a id="toc19"></a></p>
<h2>History</h2>
<p>Here we mark only major features added to the library. Small refactorings
and bug fixes are not reported here.</p>
<ul>
<li>v 0.3.0: templated types, animation and objects in scene, api cleanups</li>
<li>v 0.2.0: various bug fixes and improvement to OpenGL drawing and widgets</li>
<li>v 0.1.0: initial release after refactoring</li>
</ul>
<p><a id="api"></a></p>
<p><a id="toc20"></a></p>
<h2>API Documentation</h2>
<p><a id="toc21"></a></p>
<h3>Basic math constants and functions</h3>
<h4>Typedef byte</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">byte</span> <span class="o">=</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="p">;</span>
</code></pre></div>


<p>Convenient typedef for bytes.</p>
<h4>Typedef uint</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">uint</span> <span class="o">=</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">;</span>
</code></pre></div>


<p>Convenient typedef for unsigned ints.</p>
<h4>Constant pif</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">pif</span> <span class="o">=</span> <span class="mf">3.14159265f</span><span class="p">;</span>
</code></pre></div>


<p>Pi (float).</p>
<h4>Constant pi</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.1415926535897932384626433832795</span><span class="p">;</span>
</code></pre></div>


<p>Pi (double).</p>
<h4>Constant flt_max</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">flt_max</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
</code></pre></div>


<p>Shortcat for float max value.</p>
<h4>Constant flt_min</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">flt_min</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">lowest</span><span class="p">();</span>
</code></pre></div>


<p>Shortcat for float min value.</p>
<h4>Constant flt_eps</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">flt_eps</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">epsilon</span><span class="p">();</span>
</code></pre></div>


<p>Shortcat for float epsilon.</p>
<h4>Constant int_max</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">int_max</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
</code></pre></div>


<p>Shortcat for int max value.</p>
<h4>Constant int_min</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">int_min</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">();</span>
</code></pre></div>


<p>Shortcat for int min value.</p>
<h4>Function sqrt()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Square root.</p>
<h4>Function pow()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">auto</span> <span class="n">pow</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T1</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Power.</p>
<h4>Function exp()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">exp</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Exponential.</p>
<h4>Function log()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">log</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Logarithm.</p>
<h4>Function sin()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">sin</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Sine.</p>
<h4>Function cos()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">cos</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Cosine.</p>
<h4>Function tan()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">tan</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Tangent.</p>
<h4>Function asin()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">asin</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Arc sine.</p>
<h4>Function acos()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">acos</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Arc cosine.</p>
<h4>Function atan()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">atan</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Arc tangent.</p>
<h4>Function atan2()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">auto</span> <span class="n">atan2</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T1</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Arc tangent.</p>
<h4>Function abs()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">abs</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Absolute value.</p>
<h4>Function floor()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">floor</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Floor.</p>
<h4>Function round()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">round</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Round.</p>
<h4>Function isfinite()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">isfinite</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Check if value is finite.</p>
<h4>Function min()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">min</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="n">y</span><span class="p">);</span>
</code></pre></div>


<p>Safe minimum value.</p>
<h4>Function min()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">min</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">vs</span><span class="p">);</span>
</code></pre></div>


<p>Safe minimum value.</p>
<h4>Function max()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">max</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="n">y</span><span class="p">);</span>
</code></pre></div>


<p>Safe maximum value.</p>
<h4>Function max()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">max</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">vs</span><span class="p">);</span>
</code></pre></div>


<p>Safe maximum value.</p>
<h4>Function clamp()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">clamp</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="n">min_</span><span class="p">,</span> <span class="n">T</span> <span class="n">max_</span><span class="p">);</span>
</code></pre></div>


<p>Clamp a value between a minimum and a maximum.</p>
<h4>Function lerp()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">lerp</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">T1</span> <span class="n">u</span><span class="p">);</span>
</code></pre></div>


<p>Linear interpolation.</p>
<h4>Function bilerp()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">float</span> <span class="n">bilerp</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">,</span> <span class="n">T1</span> <span class="n">u</span><span class="p">,</span> <span class="n">T1</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>Bilinear interpolation. Order is specified like quads counter-clockwise,
so a,b,c,d correspond to parameters (0,0), (0,1), (1,1), (0,1).</p>
<h4>Function pow2()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pow2</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>
</code></pre></div>


<p>Integer power of two.</p>
<h4>Function fastfloor()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fastfloor</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">);</span>
</code></pre></div>


<p>Fast floor.</p>
<h4>Function float_to_byte()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">byte</span> <span class="nf">float_to_byte</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">);</span>
</code></pre></div>


<p>Safe float to byte conversion.</p>
<h4>Function byte_to_float()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">byte_to_float</span><span class="p">(</span><span class="n">byte</span> <span class="n">x</span><span class="p">);</span>
</code></pre></div>


<p>Safe byte to float conversion.</p>
<h4>Namespace using std::string_literals;</h4>
<p>String literals.</p>
<h4>Namespace using std::string_literals;::using std::literals;</h4>
<p>Makes literals available</p>
<p><a id="toc22"></a></p>
<h3>Fixed-size vectors</h3>
<h4>Struct vec</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">vec</span><span class="p">;</span>
</code></pre></div>


<p>Generic vector of N elements. This is used only to define template
specializations for small fixed sized vectors.</p>
<h4>Struct vec&lt;T, 1></h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">vec</span><span class="p">();</span> 
    <span class="n">vec</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">);</span> 
    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">T</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Vector of 1 element. Defined only for completeness.</p>
<ul>
<li>Members:<ul>
<li>vec():      Default constructor. Initializes to zeros.</li>
<li>vec():      Element constructor.</li>
<li>operator<a href=""></a>:      Element access.</li>
<li>operator<a href=""></a>:      Element access.</li>
<li>x:      Element data.</li>
</ul>
</li>
</ul>
<h4>Struct vec&lt;T, 2></h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">vec</span><span class="p">();</span> 
    <span class="k">explicit</span> <span class="nf">vec</span><span class="p">(</span><span class="n">T</span> <span class="n">vv</span><span class="p">);</span> 
    <span class="n">vec</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="n">y</span><span class="p">);</span> 
    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">T</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Vector of 2 elements.</p>
<ul>
<li>Members:<ul>
<li>vec():      Default constructor. Initializes to zeros.</li>
<li>vec():      Element constructor.</li>
<li>vec():      Element constructor.</li>
<li>operator<a href=""></a>:      Element access.</li>
<li>operator<a href=""></a>:      Element access.</li>
<li>x:      Element data.</li>
<li>y:      Element data.</li>
</ul>
</li>
</ul>
<h4>Struct vec&lt;T, 3></h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">vec</span><span class="p">();</span> 
    <span class="k">explicit</span> <span class="nf">vec</span><span class="p">(</span><span class="n">T</span> <span class="n">vv</span><span class="p">);</span> 
    <span class="n">vec</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="n">y</span><span class="p">,</span> <span class="n">T</span> <span class="n">z</span><span class="p">);</span> 
    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">T</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">z</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Vector of 3 elements.</p>
<ul>
<li>Members:<ul>
<li>vec():      Default constructor. Initializes to zeros.</li>
<li>vec():      Element constructor</li>
<li>vec():      Element constructor</li>
<li>operator<a href=""></a>:      Element access</li>
<li>operator<a href=""></a>:      Element access</li>
<li>x:      Element data</li>
<li>y:      Element data</li>
<li>z:      Element data</li>
</ul>
</li>
</ul>
<h4>Struct vec&lt;T, 4></h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">vec</span><span class="p">();</span> 
    <span class="k">explicit</span> <span class="nf">vec</span><span class="p">(</span><span class="n">T</span> <span class="n">vv</span><span class="p">);</span> 
    <span class="n">vec</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="n">y</span><span class="p">,</span> <span class="n">T</span> <span class="n">z</span><span class="p">,</span> <span class="n">T</span> <span class="n">w</span><span class="p">);</span> 
    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">T</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">z</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">w</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Vector of 4 elements.</p>
<ul>
<li>Members:<ul>
<li>vec():      Default constructor.  Initializes to zeros.</li>
<li>vec():      Element constructor.</li>
<li>vec():      Element constructor.</li>
<li>operator<a href=""></a>:      Element access.</li>
<li>operator<a href=""></a>:      Element access.</li>
<li>x:      Element data.</li>
<li>y:      Element data.</li>
<li>z:      Element data.</li>
<li>w:      Element data.</li>
</ul>
</li>
</ul>
<h4>Typedef vec1f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">vec1f</span> <span class="o">=</span> <span class="n">vec</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>1-dimensional float vector.</p>
<h4>Typedef vec2f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">vec2f</span> <span class="o">=</span> <span class="n">vec</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>2-dimensional float vector.</p>
<h4>Typedef vec3f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">vec3f</span> <span class="o">=</span> <span class="n">vec</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>3-dimensional float vector</p>
<h4>Typedef vec4f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">vec4f</span> <span class="o">=</span> <span class="n">vec</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>4-dimensional float vector</p>
<h4>Typedef vec1i</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">vec1i</span> <span class="o">=</span> <span class="n">vec</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>1-dimensional int vector.</p>
<h4>Typedef vec2i</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">vec2i</span> <span class="o">=</span> <span class="n">vec</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>2-dimensional int vector.</p>
<h4>Typedef vec3i</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">vec3i</span> <span class="o">=</span> <span class="n">vec</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>3-dimensional int vector.</p>
<h4>Typedef vec4i</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">vec4i</span> <span class="o">=</span> <span class="n">vec</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>4-dimensional int vector.</p>
<h4>Typedef vec4b</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">vec4b</span> <span class="o">=</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">byte</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>4-dimensional byte vector.</p>
<h4>Constant zero1f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">zero1f</span> <span class="o">=</span> <span class="n">vec1f</span><span class="p">();</span>
</code></pre></div>


<p>1-dimensional float zero vector.</p>
<h4>Constant zero2f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">zero2f</span> <span class="o">=</span> <span class="n">vec2f</span><span class="p">();</span>
</code></pre></div>


<p>2-dimensional float zero vector.</p>
<h4>Constant zero3f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">zero3f</span> <span class="o">=</span> <span class="n">vec3f</span><span class="p">();</span>
</code></pre></div>


<p>3-dimensional float zero vector.</p>
<h4>Constant zero4f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">zero4f</span> <span class="o">=</span> <span class="n">vec4f</span><span class="p">();</span>
</code></pre></div>


<p>4-dimensional float zero vector.</p>
<h4>Constant zero1i</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">zero1i</span> <span class="o">=</span> <span class="n">vec1i</span><span class="p">();</span>
</code></pre></div>


<p>1-dimensional int zero vector.</p>
<h4>Constant zero2i</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">zero2i</span> <span class="o">=</span> <span class="n">vec2i</span><span class="p">();</span>
</code></pre></div>


<p>2-dimensional int zero vector.</p>
<h4>Constant zero3i</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">zero3i</span> <span class="o">=</span> <span class="n">vec3i</span><span class="p">();</span>
</code></pre></div>


<p>3-dimensional int zero vector.</p>
<h4>Constant zero4i</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">zero4i</span> <span class="o">=</span> <span class="n">vec4i</span><span class="p">();</span>
</code></pre></div>


<p>4-dimensional int zero vector.</p>
<h4>Constant zero4b</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">zero4b</span> <span class="o">=</span> <span class="n">vec4b</span><span class="p">();</span>
</code></pre></div>


<p>4-dimensional byte zero vector.</p>
<h4>Function begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span><span class="o">*</span> <span class="n">begin</span><span class="p">(</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Element iteration.</p>
<h4>Function begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">begin</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Element iteration.</p>
<h4>Function end()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span><span class="o">*</span> <span class="n">end</span><span class="p">(</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Element iteration.</p>
<h4>Function end()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">end</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Element iteration.</p>
<h4>Function data()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span><span class="o">*</span> <span class="n">data</span><span class="p">(</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Element access.</p>
<h4>Function data()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">data</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Element access.</p>
<h4>Function size()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="n">size</span><span class="p">(</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Number of elements.</p>
<h4>Function empty()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">(</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Empty check (always false for useful for templated code).</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector equality.</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector inequality.</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector equality.</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector inequality.</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector equality.</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector inequality.</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector equality.</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector inequality.</p>
<h4>Function operator&lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector comparison using lexicographic order, useful for map.</p>
<h4>Function operator&lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector comparison using lexicographic order, useful for map.</p>
<h4>Function operator&lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector comparison using lexicographic order, useful for map.</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Vector unary plus (for completeness).</p>
<h4>Function operator-()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Vector negation.</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector sum.</p>
<h4>Function operator-()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector difference.</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector scalar product.</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T1</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector scalar product.</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector scalar product.</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector scalar division.</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T1</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector scalar division.</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="n">T1</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector scalar division.</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Vector unary plus (for completeness).</p>
<h4>Function operator-()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Vector negation.</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector sum.</p>
<h4>Function operator-()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector operator -.</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector scalar product.</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T1</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector scalar product.</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="n">T1</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector scalar product.</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector scalar division.</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T1</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector scalar division.</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="n">T1</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector scalar division.</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Vector unary plus (for completeness).</p>
<h4>Function operator-()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Vector negation.</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector sum.</p>
<h4>Function operator-()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector difference.</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector scalar product.</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector scalar product.</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector scalar product.</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector scalar division.</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T1</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector scalar division.</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="n">T1</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector scalar division.</p>
<h4>Function operator+=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector assignment.</p>
<h4>Function operator-=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">-=</span><span class="p">(</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector assignment.</p>
<h4>Function operator*=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">*=</span><span class="p">(</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector assignment.</p>
<h4>Function operator*=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">*=</span><span class="p">(</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T1</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector assignment.</p>
<h4>Function operator/=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">/=</span><span class="p">(</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector assignment.</p>
<h4>Function operator/=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">/=</span><span class="p">(</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T1</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector assignment.</p>
<h4>Function dot()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">dot</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector dot product.</p>
<h4>Function dot()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">dot</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector dot product.</p>
<h4>Function dot()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">dot</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector dot product.</p>
<h4>Function cross()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">cross</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector cross product.</p>
<h4>Function cross()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">cross</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Vector cross product.</p>
<h4>Function length()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">length</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Vector length.</p>
<h4>Function normalize()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">normalize</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Vector normalization.</p>
<h4>Function angle()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">angle</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Angle between vectors.</p>
<h4>Function slerp()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">slerp</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">T1</span> <span class="n">u</span><span class="p">);</span>
</code></pre></div>


<p>Vector spherical linear interpolation (vectors have to be normalized).</p>
<h4>Function orthogonal()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">orthogonal</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>Orthogonal vector.</p>
<h4>Function orthonormalize()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">orthonormalize</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Orthonormalize two vectors.</p>
<h4>Function reflect()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">reflect</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">w</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">n</span><span class="p">);</span>
</code></pre></div>


<p>Reflected vector.</p>
<h4>Function refract()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">refract</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">w</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">n</span><span class="p">,</span> <span class="n">T</span> <span class="n">eta</span><span class="p">);</span>
</code></pre></div>


<p>Refracted vector.</p>
<h4>Function clamp()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">clamp</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="n">T1</span> <span class="n">min</span><span class="p">,</span> <span class="n">T1</span> <span class="n">max</span><span class="p">);</span>
</code></pre></div>


<p>Component-wise clamp.</p>
<h4>Function clamp()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">clamp</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="n">T1</span> <span class="n">min</span><span class="p">,</span> <span class="n">T1</span> <span class="n">max</span><span class="p">);</span>
</code></pre></div>


<p>Component-wise clamp.</p>
<h4>Function clamp()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">clamp</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="n">T1</span> <span class="n">min</span><span class="p">,</span> <span class="n">T1</span> <span class="n">max</span><span class="p">);</span>
</code></pre></div>


<p>Component-wise clamp.</p>
<h4>Function clamplen()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">clamplen</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="n">T1</span> <span class="n">max</span><span class="p">);</span>
</code></pre></div>


<p>Clamp a vector to a maximum length.</p>
<h4>Function min_element()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="n">min_element</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Index of minimum element.</p>
<h4>Function min_element_value()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">min_element_value</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Value of minimum element.</p>
<h4>Function max_element()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="n">max_element</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Index of maximum element.</p>
<h4>Function max_element_value()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">max_element_value</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Value of maximum element.</p>
<h4>Function float_to_byte()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4b</span> <span class="nf">float_to_byte</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Element-wise float to byte conversion.</p>
<h4>Function byte_to_float()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="nf">byte_to_float</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4b</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Element-wise byte to float conversion.</p>
<h4>Function operator&lt;&lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Stream write.</p>
<h4>Function operator>>()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Stream read.</p>
<h4>Struct hash&lt;ygl::vec&lt;T, N>></h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">ygl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
</code></pre></div>


<p>Hash functor for vector for use with unordered_map</p>
<p><a id="toc23"></a></p>
<h3>Fixed-size matrices</h3>
<h4>Struct mat</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">mat</span><span class="p">;</span>
</code></pre></div>


<p>Generic matrix of NxN elements. This is used only to define template
specializations for small fixed-sized matrices.</p>
<h4>Struct mat&lt;T, 2></h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">mat</span><span class="p">();</span> 
    <span class="k">explicit</span> <span class="nf">mat</span><span class="p">(</span><span class="n">T</span> <span class="n">vv</span><span class="p">);</span> 
    <span class="n">mat</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span> 
    <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Matrix of 2x2 elements stored in column-major format.</p>
<ul>
<li>Members:<ul>
<li>mat():      Default constructor. Initializes to identity matrix.</li>
<li>mat():      Constructs a matrix with the given diagonal.</li>
<li>mat():      Constructs a matrix from its columns.</li>
<li>operator<a href=""></a>:      Column access.</li>
<li>operator<a href=""></a>:      Column access.</li>
<li>x:      Column data.</li>
<li>y:      Column data.</li>
</ul>
</li>
</ul>
<h4>Struct mat&lt;T, 3></h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">mat</span><span class="p">();</span> 
    <span class="k">explicit</span> <span class="nf">mat</span><span class="p">(</span><span class="n">T</span> <span class="n">vv</span><span class="p">);</span> 
    <span class="n">mat</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">z</span><span class="p">);</span> 
    <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">z</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Matrix of 3x3 elements stored in column major format.
Colums access via operator[].</p>
<ul>
<li>Members:<ul>
<li>mat():      Default constructor. Initializes to identity matrix.</li>
<li>mat():      Constructs a matrix with the given diagonal.</li>
<li>mat():      Constructs a matrix from its columns.</li>
<li>operator<a href=""></a>:      Column access.</li>
<li>operator<a href=""></a>:      Column access.</li>
<li>x:      Column data.</li>
<li>y:      Column data.</li>
<li>z:      Column data.</li>
</ul>
</li>
</ul>
<h4>Struct mat&lt;T, 4></h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">mat</span><span class="p">();</span> 
    <span class="k">explicit</span> <span class="nf">mat</span><span class="p">(</span><span class="kt">float</span> <span class="n">vv</span><span class="p">);</span> 
    <span class="n">mat</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">z</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">w</span><span class="p">);</span> 
    <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">z</span><span class="p">;</span>
    <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">w</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Matrix of 4x4 elements stored in column major format.
Colums access via operator[].</p>
<ul>
<li>Members:<ul>
<li>mat():      Default constructor. Initializes to identity matrix.</li>
<li>mat():      Constructs a matrix with the given diagonal.</li>
<li>mat():      Constructs a matrix from its columns.</li>
<li>operator<a href=""></a>:      Column access.</li>
<li>operator<a href=""></a>:      Column access.</li>
<li>x:      Column data.</li>
<li>y:      Column data.</li>
<li>z:      Column data.</li>
<li>w:      Column data.</li>
</ul>
</li>
</ul>
<h4>Typedef mat2f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">mat2f</span> <span class="o">=</span> <span class="n">mat</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>2-dimensional float matrix.</p>
<h4>Typedef mat3f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">mat3f</span> <span class="o">=</span> <span class="n">mat</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>3-dimensional float matrix.</p>
<h4>Typedef mat4f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">mat4f</span> <span class="o">=</span> <span class="n">mat</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>4-dimensional float matrix.</p>
<h4>Constant identity_mat2f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">identity_mat2f</span> <span class="o">=</span> <span class="n">mat2f</span><span class="p">();</span>
</code></pre></div>


<p>2-dimensional float identity matrix.</p>
<h4>Constant identity_mat3f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">identity_mat3f</span> <span class="o">=</span> <span class="n">mat3f</span><span class="p">();</span>
</code></pre></div>


<p>3-dimensional float identity matrix.</p>
<h4>Constant identity_mat4f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">identity_mat4f</span> <span class="o">=</span> <span class="n">mat4f</span><span class="p">();</span>
</code></pre></div>


<p>4-dimensional float identity matrix.</p>
<h4>Function begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;*</span> <span class="n">begin</span><span class="p">(</span><span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">m</span><span class="p">);</span>
</code></pre></div>


<p>Column iteration.</p>
<h4>Function end()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;*</span> <span class="n">end</span><span class="p">(</span><span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">m</span><span class="p">);</span>
</code></pre></div>


<p>Column iteration.</p>
<h4>Function begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;*</span> <span class="n">begin</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">m</span><span class="p">);</span>
</code></pre></div>


<p>Column iteration.</p>
<h4>Function end()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;*</span> <span class="n">end</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">m</span><span class="p">);</span>
</code></pre></div>


<p>Column iteration.</p>
<h4>Function data()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;*</span> <span class="n">data</span><span class="p">(</span><span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">m</span><span class="p">);</span>
</code></pre></div>


<p>Column access.</p>
<h4>Function data()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;*</span> <span class="n">data</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">m</span><span class="p">);</span>
</code></pre></div>


<p>Column access.</p>
<h4>Function size()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="n">size</span><span class="p">(</span><span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Number of columns.</p>
<h4>Function empty()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">(</span><span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Empty check (always false for useful for templated code).</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix equality.</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix inequality.</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix equality.</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix inequality.</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix equality.</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix inequality.</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix sum.</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T1</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix scalar product.</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T1</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix scalar division.</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix-vector product.</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix-vector product.</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix-matrix product.</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix sum.</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T1</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix scalar product.</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T1</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix scalar division.</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix-vector product.</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix-vector product.</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix-matrix product.</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix sum.</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T1</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix scalar product.</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T1</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix scalar division.</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix-vector product.</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix-vector product.</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix-matrix product.</p>
<h4>Function operator+=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix assignment.</p>
<h4>Function operator*=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">*=</span><span class="p">(</span><span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix assignment.</p>
<h4>Function operator*=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">*=</span><span class="p">(</span><span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T1</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix assignment.</p>
<h4>Function operator/=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">/=</span><span class="p">(</span><span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T1</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Matrix assignment.</p>
<h4>Function mat_diagonal()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">mat_diagonal</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Matrix diagonal.</p>
<h4>Function mat_diagonal()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">mat_diagonal</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Matrix diagonal.</p>
<h4>Function mat_diagonal()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">mat_diagonal</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Matrix diagonal.</p>
<h4>Function transpose()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">transpose</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Matrix transpose.</p>
<h4>Function transpose()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">transpose</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Matrix transpose.</p>
<h4>Function transpose()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">transpose</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Matrix transpose.</p>
<h4>Function adjugate()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">adjugate</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Matrix adjugate.</p>
<h4>Function adjugate()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">adjugate</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Matrix adjugate.</p>
<h4>Function adjugate()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">adjugate</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Matrix adjugate.</p>
<h4>Function determinant()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">determinant</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Matrix determinant.</p>
<h4>Function determinant()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">determinant</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Matrix determinant.</p>
<h4>Function determinant()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">determinant</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Matrix determinant.</p>
<h4>Function inverse()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">inverse</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Matrix inverse.</p>
<h4>Function operator&lt;&lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Stream write.</p>
<h4>Function operator>>()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Stream read.</p>
<p><a id="toc24"></a></p>
<h3>Rigid-body frames</h3>
<h4>Struct frame</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">frame</span><span class="p">;</span>
</code></pre></div>


<p>Generic frame of N elements. This is used only to define template
specializations for small fixed sized frames.</p>
<h4>Struct frame&lt;T, 3></h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">frame</span><span class="p">();</span> 
    <span class="n">frame</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">z</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">o</span><span class="p">);</span> 
    <span class="n">frame</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">t</span><span class="p">);</span> 
    <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">z</span><span class="p">;</span>
    <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Rigid transforms stored as a column-major affine matrix.
In memory, this representation is equivalent to storing an NxN rotation
followed by a Nx1 translation. Viewed this way, the representation allows
also to retrive the axis of the coordinate frame as the first N columns and
the translation as the (N+1)-th column. Colums access via operator[].
Access rotation and position with pos() and rot().</p>
<ul>
<li>Members:<ul>
<li>frame():      Default constructor. Initializes to the identity frame.</li>
<li>frame():      Basic and origin constructor. Equavalent to columns of affine matrix.</li>
<li>frame():      Rotation and traslation constructor.</li>
<li>operator<a href=""></a>:      Element/column access</li>
<li>operator<a href=""></a>:      Element/column access</li>
<li>x:      Axes and origin data</li>
<li>y:      Axes and origin data</li>
<li>z:      Axes and origin data</li>
<li>o:      Axes and origin data</li>
</ul>
</li>
</ul>
<h4>Typedef frame3f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">frame3f</span> <span class="o">=</span> <span class="n">frame</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>3-dimensional float frame.</p>
<h4>Constant identity_frame3f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">identity_frame3f</span> <span class="o">=</span>
    <span class="n">frame3f</span><span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span> <span class="p">};</span>
</code></pre></div>


<p>Indentity frame.</p>
<h4>Function begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;*</span> <span class="n">begin</span><span class="p">(</span><span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Element/column iteration.</p>
<h4>Function begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;*</span> <span class="n">begin</span><span class="p">(</span><span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Element/column iteration.</p>
<h4>Function end()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;*</span> <span class="n">end</span><span class="p">(</span><span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Element/column iteration.</p>
<h4>Function end()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;*</span> <span class="n">end</span><span class="p">(</span><span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Element/column iteration.</p>
<h4>Function data()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;*</span> <span class="n">data</span><span class="p">(</span><span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Element/column access.</p>
<h4>Function data()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;*</span> <span class="n">data</span><span class="p">(</span><span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Element/column access.</p>
<h4>Function size()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="n">size</span><span class="p">(</span><span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Number of columns in the underlying affine matrix.</p>
<h4>Function empty()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">(</span><span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Empty check (always false for useful for templated code).</p>
<h4>Function frame_to_mat()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">frame_to_mat</span><span class="p">(</span><span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Frame to matrix conversion.</p>
<h4>Function mat_to_frame()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">mat_to_frame</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Matrix to frame conversion.</p>
<h4>Function frame_pos()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">frame_pos</span><span class="p">(</span><span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Frame origin.</p>
<h4>Function frame_pos()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">frame_pos</span><span class="p">(</span><span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Frame origin.</p>
<h4>Function frame_rot()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">frame_rot</span><span class="p">(</span><span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Frame rotation</p>
<h4>Function frame_rot()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">frame_rot</span><span class="p">(</span><span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Frame rotation</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Frame equality.</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Frame inequality.</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Frame composition, equivalent to affine matrix product.</p>
<h4>Function inverse()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">inverse</span><span class="p">(</span><span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Frame inverse, equivalent to rigid affine inverse.</p>
<h4>Function operator&lt;&lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Stream write.</p>
<h4>Function operator>>()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Stream read.</p>
<p><a id="toc25"></a></p>
<h3>Quaternions</h3>
<h4>Struct quat</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">quat</span><span class="p">;</span>
</code></pre></div>


<p>Generic quaternion of N elements. This is used only to define template
specializations for small fixed sized quaternions.</p>
<h4>Struct quat&lt;T, 4></h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">quat</span><span class="p">();</span> 
    <span class="k">explicit</span> <span class="nf">quat</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">vv</span><span class="p">);</span> 
    <span class="k">explicit</span> <span class="k">operator</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">T</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">z</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">w</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Quaternions implemented as 4-dimensional vector as xi + yj + zk + w.
Element access via operator[]. The cosde here assume the use as unit
quaternions for rotations.</p>
<ul>
<li>Members:<ul>
<li>quat():      Default constructor. Initializes to identity rotation.</li>
<li>quat():      Conversion from vec.</li>
<li>operator 4&gt;():      Conversion to vec.</li>
<li>operator<a href=""></a>:      Element access.</li>
<li>operator<a href=""></a>:      Element access.</li>
<li>x:      Element data.</li>
<li>y:      Element data.</li>
<li>z:      Element data.</li>
<li>w:      Element data.</li>
</ul>
</li>
</ul>
<h4>Typedef quat4f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">quat4f</span> <span class="o">=</span> <span class="n">quat</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>4-dimensional float quaternion.</p>
<h4>Constant identity_quat4f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">identity_quat4f</span> <span class="o">=</span> <span class="n">quat4f</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
</code></pre></div>


<p>Float identity quaternion.</p>
<h4>Function begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span><span class="o">*</span> <span class="n">begin</span><span class="p">(</span><span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Element iteration.</p>
<h4>Function begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">begin</span><span class="p">(</span><span class="k">const</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Element iteration.</p>
<h4>Function end()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span><span class="o">*</span> <span class="n">end</span><span class="p">(</span><span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Element iteration.</p>
<h4>Function end()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">end</span><span class="p">(</span><span class="k">const</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Element iteration.</p>
<h4>Function data()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span><span class="o">*</span> <span class="n">data</span><span class="p">(</span><span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Element access.</p>
<h4>Function data()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">data</span><span class="p">(</span><span class="k">const</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Element access.</p>
<h4>Function size()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="n">size</span><span class="p">(</span><span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Number of elements.</p>
<h4>Function empty()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">(</span><span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Empty check (always false for useful for templated code).</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Quaternion equality.</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Quaternion inequality.</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Quaternion sum.</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T1</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Quaternion scalar product.</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T1</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Quaternion scalar division.</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Quaternion product.</p>
<h4>Function conjugate()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">conjugate</span><span class="p">(</span><span class="k">const</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>Quaternion conjugate.</p>
<h4>Function inverse()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">inverse</span><span class="p">(</span><span class="k">const</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>Quaternion inverse.</p>
<h4>Function normalize()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">normalize</span><span class="p">(</span><span class="k">const</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>Quaternion normalization.</p>
<h4>Function slerp()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">slerp</span><span class="p">(</span><span class="k">const</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">T1</span> <span class="n">t</span><span class="p">);</span>
</code></pre></div>


<p>Quaternion spherical linear interpolation.</p>
<h4>Function operator&lt;&lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Stream write.</p>
<h4>Function operator>>()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Stream read.</p>
<p><a id="toc26"></a></p>
<h3>Axis-aligned bounding boxes</h3>
<h4>Struct bbox</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">bbox</span> <span class="p">{</span>
    <span class="n">bbox</span><span class="p">();</span> 
    <span class="n">bbox</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">M</span><span class="p">);</span> 
    <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">min</span><span class="p">;</span>
    <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Axis aligned bounding box represented as a min/max vector pairs.</p>
<ul>
<li>Members:<ul>
<li>bbox():      Initializes an invalid bbox.</li>
<li>bbox():      Element constructor with min/max values.</li>
<li>operator<a href=""></a>:      Element access.</li>
<li>operator<a href=""></a>:      Element access.</li>
<li>min:      Minimum bounds.</li>
<li>max:      Maximum bounds.</li>
</ul>
</li>
</ul>
<h4>Typedef bbox1f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">bbox1f</span> <span class="o">=</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>1-dimensional float bounding box.</p>
<h4>Typedef bbox2f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">bbox2f</span> <span class="o">=</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>2-dimensional float bounding box.</p>
<h4>Typedef bbox3f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">bbox3f</span> <span class="o">=</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>3-dimensional float bounding box.</p>
<h4>Typedef bbox4f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">bbox4f</span> <span class="o">=</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>4-dimensional float bounding box.</p>
<h4>Constant invalid_bbox1f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">invalid_bbox1f</span> <span class="o">=</span> <span class="n">bbox1f</span><span class="p">();</span>
</code></pre></div>


<p>1-dimensional float empty bbox.</p>
<h4>Constant invalid_bbox2f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">invalid_bbox2f</span> <span class="o">=</span> <span class="n">bbox2f</span><span class="p">();</span>
</code></pre></div>


<p>2-dimensional float empty bbox.</p>
<h4>Constant invalid_bbox3f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">invalid_bbox3f</span> <span class="o">=</span> <span class="n">bbox3f</span><span class="p">();</span>
</code></pre></div>


<p>3-dimensional float empty bbox.</p>
<h4>Constant invalid_bbox4f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">invalid_bbox4f</span> <span class="o">=</span> <span class="n">bbox4f</span><span class="p">();</span>
</code></pre></div>


<p>4-dimensional float empty bbox.</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Bounding box equality.</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Bounding box inequality.</p>
<h4>Function bbox_center()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">bbox_center</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Bounding box center.</p>
<h4>Function bbox_diagonal()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">bbox_diagonal</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Bounding box diagonal.</p>
<h4>Function expand()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">expand</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Expands a bounding box with a point.</p>
<h4>Function expand()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">expand</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Expands a bounding box with a point.</p>
<h4>Function expand()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">expand</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Expands a bounding box with a point.</p>
<h4>Function expand()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">expand</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Expands a bounding box with a point.</p>
<h4>Function expand()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">expand</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Expands a bounding box with a point.</p>
<h4>Function expand()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">expand</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Expands a bounding box with a bounding box.</p>
<h4>Function expand()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">expand</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Expands a bounding box with a bounding box.</p>
<h4>Function expand()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">expand</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Expands a bounding box with a bounding box.</p>
<h4>Function expand()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">expand</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Expands a bounding box with a bounding box.</p>
<h4>Function contains()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Check if a bounding box contains a point.</p>
<h4>Function contains()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Check if a bounding box contains a bounding box.</p>
<h4>Function operator+=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Expands a bounding box with a point.</p>
<h4>Function operator+=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Expands a bounding box with a bounding box.</p>
<h4>Function make_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">make_bbox</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;*</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>Initialize a bonding box from a list of points.</p>
<h4>Function make_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">make_bbox</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&gt;&amp;</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>Initialize a bonding box from a list of points.</p>
<h4>Function bbox_corners()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">bbox_corners</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Computes the corners of a bounding boxes.</p>
<h4>Function bbox_corners()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">bbox_corners</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Computes the corners of a bounding boxes.</p>
<h4>Function operator&lt;&lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Stream write.</p>
<h4>Function operator>>()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Stream read.</p>
<p><a id="toc27"></a></p>
<h3>Primitive bounding boxes</h3>
<h4>Function point_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">point_bbox</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">p</span><span class="p">,</span> <span class="n">T1</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div>


<p>Point bounds.</p>
<h4>Function line_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">line_bbox</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="n">T1</span> <span class="n">r0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">T1</span> <span class="n">r1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div>


<p>Line bounds.</p>
<h4>Function triangle_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">triangle_bbox</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">v2</span><span class="p">);</span>
</code></pre></div>


<p>Triangle bounds.</p>
<h4>Function quad_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">quad_bbox</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">v1</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">v3</span><span class="p">);</span>
</code></pre></div>


<p>Quad bounds.</p>
<h4>Function tetrahedron_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">tetrahedron_bbox</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">v1</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">v3</span><span class="p">);</span>
</code></pre></div>


<p>Tetrahedron bounds.</p>
<p><a id="toc28"></a></p>
<h3>Rays</h3>
<h4>Struct ray</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">ray</span> <span class="p">{</span>
    <span class="n">ray</span><span class="p">();</span> 
    <span class="n">ray</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">o</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">d</span><span class="p">,</span> <span class="n">T</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">T</span> <span class="n">tmax</span> <span class="o">=</span> <span class="n">flt_max</span><span class="p">);</span> 
    <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">o</span><span class="p">;</span>
    <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">tmin</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">tmax</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Rays with origin, direction and min/max t value. Origin and directions are
of N-elements.</p>
<ul>
<li>Members:<ul>
<li>ray():      Default constructor. Initializes to an invalid ray.</li>
<li>ray():      Initializes a ray from its elements.</li>
<li>o:      origin</li>
<li>d:      direction</li>
<li>tmin:      minimum distance</li>
<li>tmax:      maximum distance</li>
</ul>
</li>
</ul>
<h4>Typedef ray2f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">ray2f</span> <span class="o">=</span> <span class="n">ray</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>2-dimensional float ray.</p>
<h4>Typedef ray3f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">ray3f</span> <span class="o">=</span> <span class="n">ray</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>3-dimensional float ray.</p>
<h4>Typedef ray4f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">ray4f</span> <span class="o">=</span> <span class="n">ray</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>4-dimensional float ray.</p>
<h4>Function make_ray()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">ray</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">make_ray</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">o</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">d</span><span class="p">,</span> <span class="n">T</span> <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-4</span><span class="n">f</span><span class="p">);</span>
</code></pre></div>


<p>Construct a ray using a default epsilon.</p>
<h4>Function make_segment()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">ray</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">make_segment</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">p2</span><span class="p">,</span> <span class="n">T</span> <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-4</span><span class="n">f</span><span class="p">);</span>
</code></pre></div>


<p>Construct a ray segment using a default epsilon.</p>
<h4>Function operator&lt;&lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Stream write.</p>
<h4>Function operator>>()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="n">ray</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Stream read.</p>
<p><a id="toc29"></a></p>
<h3>Transforms</h3>
<h4>Function transform_point()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">transform_point</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Transforms a point by a matrix.</p>
<h4>Function transform_point()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">transform_point</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Transforms a point by a matrix.</p>
<h4>Function transform_vector()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">transform_vector</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Transforms a vector by a matrix.</p>
<h4>Function transform_vector()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">transform_vector</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Transforms a vector by a matrix.</p>
<h4>Function transform_direction()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">transform_direction</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Transforms a direction by a matrix.</p>
<h4>Function transform_ray()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">ray</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">transform_ray</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Transforms a ray by a matrix, leaving the direction not normalized.</p>
<h4>Function transform_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">transform_bbox</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>transforms a bbox by a matrix</p>
<h4>Function transform_point()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">transform_point</span><span class="p">(</span><span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Transforms a point by a frame, i.e. an affine transform.</p>
<h4>Function transform_point()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">transform_point</span><span class="p">(</span><span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Transforms a point by a frame, i.e. an affine transform.</p>
<h4>Function transform_vector()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">transform_vector</span><span class="p">(</span><span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Transforms a vector by a frame, i.e. an affine transform.</p>
<h4>Function transform_vector()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">transform_vector</span><span class="p">(</span><span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Transforms a vector by a frame, i.e. an affine transform.</p>
<h4>Function transform_direction()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">transform_direction</span><span class="p">(</span><span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Transforms a direction by a frame, i.e. an affine transform.</p>
<h4>Function transform_frame()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">transform_frame</span><span class="p">(</span><span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Transforms a frame by a frame, i.e. an affine transform.</p>
<h4>Function transform_ray()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">ray</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">transform_ray</span><span class="p">(</span><span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Transforms a ray by a frame, i.e. an affine transform.</p>
<h4>Function transform_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">transform_bbox</span><span class="p">(</span><span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Transforms a bbox by a frame, i.e. an affine transform.</p>
<h4>Function transform_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">transform_bbox</span><span class="p">(</span><span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Transforms a bbox by a frame, i.e. an affine transform.</p>
<h4>Function transform_point_inverse()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">transform_point_inverse</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Inverse transforms a point by a frame, assuming a rigid transform.</p>
<h4>Function transform_point_inverse()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">transform_point_inverse</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Inverse transforms a point by a frame, assuming a rigid transform.</p>
<h4>Function transform_vector_inverse()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">transform_vector_inverse</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Inverse transforms a vector by a frame, assuming a rigid transform.</p>
<h4>Function transform_vector_inverse()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">transform_vector_inverse</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Inverse transforms a vector by a frame, assuming a rigid transform.</p>
<h4>Function transform_direction_inverse()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">transform_direction_inverse</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Inverse transforms a direction by a frame, assuming a rigid transform.</p>
<h4>Function transform_ray_inverse()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">ray</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">transform_ray_inverse</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Inverse transforms a direction by a frame, assuming a rigid transform.</p>
<h4>Function transform_bbox_inverse()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">transform_bbox_inverse</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Inverse transforms a bbox by a frame, assuming a rigid transform.</p>
<h4>Function translation_frame()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">translation_frame</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Translation affine transform.</p>
<h4>Function scaling_frame()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">scaling_frame</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Scaling affine transform; this is not rigid and here for symmatry of API.</p>
<h4>Function rotation_frame()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">rotation_frame</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">axis</span><span class="p">,</span> <span class="n">T1</span> <span class="n">angle</span><span class="p">);</span>
</code></pre></div>


<p>Rotation affine transform.</p>
<h4>Function rotation_frame()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">rotation_frame</span><span class="p">(</span><span class="k">const</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>Rotation affine transform.</p>
<h4>Function lookat_frame()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">lookat_frame</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">eye</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">center</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">up</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">inv_xz</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>OpenGL lookat frame. Z-axis can be inverted with inv_xz.</p>
<h4>Function frustum_mat()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">frustum_mat</span><span class="p">(</span><span class="n">T</span> <span class="n">l</span><span class="p">,</span> <span class="n">T</span> <span class="n">r</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">,</span> <span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">T</span> <span class="n">n</span><span class="p">,</span> <span class="n">T</span> <span class="n">f</span><span class="p">);</span>
</code></pre></div>


<p>OpenGL frustum matrix.</p>
<h4>Function ortho_mat()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">ortho_mat</span><span class="p">(</span><span class="n">T</span> <span class="n">l</span><span class="p">,</span> <span class="n">T</span> <span class="n">r</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">,</span> <span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">T</span> <span class="n">n</span><span class="p">,</span> <span class="n">T</span> <span class="n">f</span><span class="p">);</span>
</code></pre></div>


<p>OpenGL orthographic matrix.</p>
<h4>Function ortho2d_mat()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">ortho2d_mat</span><span class="p">(</span><span class="n">T</span> <span class="n">left</span><span class="p">,</span> <span class="n">T</span> <span class="n">right</span><span class="p">,</span> <span class="n">T</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">T</span> <span class="n">top</span><span class="p">);</span>
</code></pre></div>


<p>OpenGL orthographic 2D matrix.</p>
<h4>Function ortho_mat()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">ortho_mat</span><span class="p">(</span><span class="n">T</span> <span class="n">xmag</span><span class="p">,</span> <span class="n">T</span> <span class="n">ymag</span><span class="p">,</span> <span class="n">T</span> <span class="n">near</span><span class="p">,</span> <span class="n">T</span> <span class="n">far</span><span class="p">);</span>
</code></pre></div>


<p>OpenGL orthographic matrix.</p>
<h4>Function perspective_mat()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">perspective_mat</span><span class="p">(</span><span class="n">T</span> <span class="n">fovy</span><span class="p">,</span> <span class="n">T</span> <span class="n">aspect</span><span class="p">,</span> <span class="n">T</span> <span class="n">near</span><span class="p">,</span> <span class="n">T</span> <span class="n">far</span><span class="p">);</span>
</code></pre></div>


<p>OpenGL perspective matrix.</p>
<h4>Function perspective_mat()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">perspective_mat</span><span class="p">(</span><span class="n">T</span> <span class="n">fovy</span><span class="p">,</span> <span class="n">T</span> <span class="n">aspect</span><span class="p">,</span> <span class="n">T</span> <span class="n">near</span><span class="p">);</span>
</code></pre></div>


<p>OpenGL infinite perspective matrix.</p>
<h4>Function rotation_axisangle()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">rotation_axisangle</span><span class="p">(</span><span class="k">const</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Rotation affine transform.</p>
<h4>Function rotation_quat()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">rotation_quat</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">axis</span><span class="p">,</span> <span class="n">T</span> <span class="n">angle</span><span class="p">);</span>
</code></pre></div>


<p>Axis-angle to quaternion conversion.</p>
<h4>Function rotation_quat()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">rotation_quat</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">m_</span><span class="p">);</span>
</code></pre></div>


<p>Rotation matrix to quaternion conversion.</p>
<h4>Function decompose_frame()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&gt;</span> <span class="n">decompose_frame</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">m</span><span class="p">);</span>
</code></pre></div>


<p>Decompose an affine matrix into translation, rotation, scale.
Assumes there is no shear.</p>
<h4>Function decompose_frame()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&gt;</span> <span class="n">decompose_frame</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">m</span><span class="p">);</span>
</code></pre></div>


<p>Decompose an affine matrix into translation, rotation, scale.
Assumes there is no shear and the matrix is affine.</p>
<h4>Function compose_frame()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">compose_frame</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">translation</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">rotation</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">scale</span><span class="p">);</span>
</code></pre></div>


<p>Decompose an affine matrix into translation, rotation, scale.
Assumes there is no shear and the matrix is affine.</p>
<h4>Function compose_frame()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">compose_frame</span><span class="p">(</span><span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">translation</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">quat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">rotation</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">scale</span><span class="p">);</span>
</code></pre></div>


<p>Decompose an affine matrix into translation, rotation, scale.
Assumes there is no shear and the matrix is affine.</p>
<p><a id="toc30"></a></p>
<h3>User interface utilities</h3>
<h4>Function camera_turntable()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">camera_turntable</span><span class="p">(</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">from</span><span class="p">,</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">to</span><span class="p">,</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">up</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">rotate</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">dolly</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">pan</span><span class="p">);</span>
</code></pre></div>


<p>Turntable for UI navigation.</p>
<h4>Function camera_turntable()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">camera_turntable</span><span class="p">(</span><span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">frame</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">focus</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">rotate</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">dolly</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">pan</span><span class="p">);</span>
</code></pre></div>


<p>Turntable for UI navigation.</p>
<h4>Function camera_fps()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">camera_fps</span><span class="p">(</span><span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">frame</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">transl</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">rotate</span><span class="p">);</span>
</code></pre></div>


<p>FPS camera for UI navigation.</p>
<p><a id="toc31"></a></p>
<h3>Random number generation</h3>
<h4>Struct rng_pcg32</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">rng_pcg32</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">state</span> <span class="o">=</span> <span class="mh">0x853c49e6748fea9bULL</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">inc</span> <span class="o">=</span> <span class="mh">0xda3e39cb94b95bdbULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>PCG random numbers. A family of random number generators that supports
multiple sequences. From http://www.pcg-random.org/</p>
<ul>
<li>Members:<ul>
<li>state:      RNG state.</li>
<li>inc:      RNG sequence. Must be odd.</li>
</ul>
</li>
</ul>
<h4>Function advance_rng()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">advance_rng</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">);</span>
</code></pre></div>


<p>Next random number.</p>
<h4>Function advance_rng()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">advance_rng</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">delta</span><span class="p">);</span>
</code></pre></div>


<p>Multi-step advance function (jump-ahead, jump-back).</p>
<h4>Function advance_rng()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">advance_rng</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">delta</span><span class="p">);</span>
</code></pre></div>


<p>Multi-step advance function (jump-ahead, jump-back).</p>
<h4>Function seed_rng()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">seed_rng</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">state</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">seq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Seeds a random number generator with a state state from the sequence seq.</p>
<h4>Function init_rng()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">rng_pcg32</span> <span class="nf">init_rng</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">state</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">seq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Init a random number generator with a state state from the sequence seq.</p>
<h4>Function next_rand1i()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">next_rand1i</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">n</span><span class="p">);</span>
</code></pre></div>


<p>Next random uint in [0,n) range with proper weighting</p>
<h4>Function next_rand1f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">next_rand1f</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">);</span>
</code></pre></div>


<p>Next random float in [0,1).</p>
<h4>Function next_rand1f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">next_rand1f</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">,</span> <span class="kt">float</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Next random float in [a,b).</p>
<h4>Function next_rand2f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="nf">next_rand2f</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">);</span>
</code></pre></div>


<p>Next random float2 in [0,1)x[0,1).</p>
<h4>Function next_rand2f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="nf">next_rand2f</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Next random float in [a.x,b.x)x[a.y,b.y).</p>
<h4>Function next_rand3f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">next_rand3f</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">);</span>
</code></pre></div>


<p>Next random float3 in [0,1)x[0,1)x[0,1).</p>
<h4>Function next_rand2f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">next_rand2f</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Next random float in [a.x,b.x)x[a.y,b.y)x[a.z,b.z).</p>
<h4>Function next_rand1d()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">double</span> <span class="nf">next_rand1d</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">);</span>
</code></pre></div>


<p>Next random double in [0, 1). Only 32 mantissa bits are filled, but still
better than float that uses 23.</p>
<h4>Function rng_distance()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">rng_distance</span><span class="p">(</span><span class="k">const</span> <span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Distance between random number generators.</p>
<h4>Function rng_shuffle()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">rng_shuffle</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">begin</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">end</span><span class="p">);</span>
</code></pre></div>


<p>Random shuffle of a sequence.</p>
<h4>Function rng_shuffle()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">rng_shuffle</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">vals</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</code></pre></div>


<p>Random shuffle of a sequence.</p>
<h4>Function rng_shuffle()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">rng_shuffle</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vals</span><span class="p">);</span>
</code></pre></div>


<p>Random shuffle of a sequence.</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Random number generator equality.</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Random number generator inequality.</p>
<p><a id="toc32"></a></p>
<h3>Monte Carlo sampling</h3>
<h4>Function sample_hemisphere()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">sample_hemisphere</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">ruv</span><span class="p">);</span>
</code></pre></div>


<p>Sample an hemispherical direction with uniform distribution.</p>
<h4>Function sample_hemisphere_pdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">sample_hemisphere_pdf</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">);</span>
</code></pre></div>


<p>Pdf for uniform hemispherical direction.</p>
<h4>Function sample_sphere()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">sample_sphere</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">ruv</span><span class="p">);</span>
</code></pre></div>


<p>Sample a spherical direction with uniform distribution.</p>
<h4>Function sample_sphere_pdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">sample_sphere_pdf</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">);</span>
</code></pre></div>


<p>Pdf for uniform spherical direction.</p>
<h4>Function sample_hemisphere_cosine()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">sample_hemisphere_cosine</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">ruv</span><span class="p">);</span>
</code></pre></div>


<p>Sample an hemispherical direction with cosine distribution.</p>
<h4>Function sample_hemisphere_cosine_pdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">sample_hemisphere_cosine_pdf</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">);</span>
</code></pre></div>


<p>Pdf for cosine hemispherical direction.</p>
<h4>Function sample_hemisphere_cospower()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">sample_hemisphere_cospower</span><span class="p">(</span><span class="kt">float</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">ruv</span><span class="p">);</span>
</code></pre></div>


<p>Sample an hemispherical direction with cosine power distribution.</p>
<h4>Function sample_hemisphere_cospower_pdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">sample_hemisphere_cospower_pdf</span><span class="p">(</span><span class="kt">float</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">);</span>
</code></pre></div>


<p>Pdf for cosine power hemispherical direction.</p>
<h4>Function sample_disk()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">sample_disk</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">ruv</span><span class="p">);</span>
</code></pre></div>


<p>Sample a point uniformly on a disk.</p>
<h4>Function sample_disk_pdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">sample_disk_pdf</span><span class="p">();</span>
</code></pre></div>


<p>Pdf for uniform disk sampling.</p>
<h4>Function sample_cylinder()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">sample_cylinder</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">ruv</span><span class="p">);</span>
</code></pre></div>


<p>Sample a point uniformly on a cylinder, without caps.</p>
<h4>Function sample_cylinder_pdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">sample_cylinder_pdf</span><span class="p">();</span>
</code></pre></div>


<p>Pdf for uniform cylinder sampling.</p>
<h4>Function sample_triangle()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="nf">sample_triangle</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">ruv</span><span class="p">);</span>
</code></pre></div>


<p>Sample a point uniformly on a triangle.</p>
<h4>Function sample_triangle()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">sample_triangle</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">ruv</span><span class="p">);</span>
</code></pre></div>


<p>Sample a point uniformly on a triangle.</p>
<h4>Function sample_triangle_pdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">sample_triangle_pdf</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">);</span>
</code></pre></div>


<p>Pdf for uniform triangle sampling, i.e. triangle area.</p>
<h4>Function sample_index()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sample_index</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">float</span> <span class="n">r</span><span class="p">);</span>
</code></pre></div>


<p>Sample an index with uniform distribution.</p>
<h4>Function sample_index_pdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">sample_index_pdf</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
</code></pre></div>


<p>Pdf for uniform index sampling.</p>
<h4>Function sample_discrete()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sample_discrete</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">cdf</span><span class="p">,</span> <span class="kt">float</span> <span class="n">r</span><span class="p">);</span>
</code></pre></div>


<p>Sample a discrete distribution represented by its cdf.</p>
<h4>Function sample_discrete_pdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">sample_discrete_pdf</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">cdf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>
</code></pre></div>


<p>Pdf for uniform discrete distribution sampling.</p>
<p><a id="toc33"></a></p>
<h3>Hashing</h3>
<h4>Function cmjs_permute()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">cmjs_permute</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">n</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">key</span><span class="p">);</span>
</code></pre></div>


<p>Computes the i-th term of a permutation of l values keyed by p.
From Correlated Multi-Jittered Sampling by Kensler @ Pixar</p>
<h4>Function cmjs_randfloat()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">cmjs_randfloat</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">key</span><span class="p">);</span>
</code></pre></div>


<p>Computes a float value by hashing i with a key p.
From Correlated Multi-Jittered Sampling by Kensler @ Pixar</p>
<h4>Function hash_uint32()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">hash_uint32</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>32 bit integer hash. Public domain code.</p>
<h4>Function hash_uint64()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">hash_uint64</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>64 bit integer hash. Public domain code.</p>
<h4>Function hash_uint64_32()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">hash_uint64_32</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>64-to-32 bit integer hash. Public domain code.</p>
<h4>Function hash_combine()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">size_t</span> <span class="nf">hash_combine</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">a</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Combines two 64 bit hashes as in boost::hash_combine.</p>
<p><a id="toc34"></a></p>
<h3>Perlin noise</h3>
<h4>Function perlin_noise()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">float</span> <span class="nf">perlin_noise</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">wrap</span> <span class="o">=</span> <span class="n">zero3i</span><span class="p">);</span>
</code></pre></div>


<p>Compute the revised Pelin noise function. Wrap provides a wrapping noise
but must be power of two (wraps at 256 anyway). For octave based noise,
good values are obtained with octaves=6 (numerber of noise calls),
lacunarity=~2.0 (spacing between successive octaves: 2.0 for warpping
output), gain=0.5 (relative weighting applied to each successive octave),
offset=1.0 (used to invert the ridges).</p>
<h4>Function perlin_ridge_noise()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">float</span> <span class="nf">perlin_ridge_noise</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span> <span class="kt">float</span> <span class="n">lacunarity</span> <span class="o">=</span> <span class="mf">2.0f</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">gain</span> <span class="o">=</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="kt">float</span> <span class="n">offset</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">octaves</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">wrap</span> <span class="o">=</span> <span class="n">zero3i</span><span class="p">);</span>
</code></pre></div>


<p>Ridge noise function. See perlin_noise() for params.</p>
<h4>Function perlin_fbm_noise()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">float</span> <span class="nf">perlin_fbm_noise</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span> <span class="kt">float</span> <span class="n">lacunarity</span> <span class="o">=</span> <span class="mf">2.0f</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">gain</span> <span class="o">=</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">octaves</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">wrap</span> <span class="o">=</span> <span class="n">zero3i</span><span class="p">);</span>
</code></pre></div>


<p>Fractal brownian motion noise. See perlin_noise() for params.</p>
<h4>Function perlin_turbulence_noise()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">float</span> <span class="nf">perlin_turbulence_noise</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span> <span class="kt">float</span> <span class="n">lacunarity</span> <span class="o">=</span> <span class="mf">2.0f</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">gain</span> <span class="o">=</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">octaves</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">wrap</span> <span class="o">=</span> <span class="n">zero3i</span><span class="p">);</span>
</code></pre></div>


<p>Fractal turbulence noise. See perlin_noise() for params.</p>
<p><a id="toc35"></a></p>
<h3>Python-like iterators</h3>
<h4>Struct range_generator</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">range_generator</span> <span class="p">{</span>
</code></pre></div>


<p>Implementation of Python-like range generator. Create it with the the
<code>range()</code> functions to use argument deduction.</p>
<h4>Function range()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">range_generator</span> <span class="nf">range</span><span class="p">(</span><span class="kt">int</span> <span class="n">max</span><span class="p">);</span>
</code></pre></div>


<p>Python-like range ierator.</p>
<h4>Function range()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">range_generator</span> <span class="nf">range</span><span class="p">(</span><span class="kt">int</span> <span class="n">min</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span><span class="p">,</span> <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Python-like range ierator.</p>
<h4>Struct enumerate_generator</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">enumerate_generator</span> <span class="p">{</span>
</code></pre></div>


<p>Implemenetation of Python-like enumerate. Create it with the function
<code>enumerate()</code> to use argument deduction.</p>
<h4>Function enumerate()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">enumerate_generator</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">enumerate</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Python-like enumerate.</p>
<h4>Function enumerate()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">enumerate_generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">enumerate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Python-like enumerate.</p>
<p><a id="toc36"></a></p>
<h3>Container operations</h3>
<h4>Function append()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">append</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Append a vector to a vector.</p>
<h4>Function join()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">join</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Append two vectors.</p>
<h4>Function get_key()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">K</span> <span class="n">get_key</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;&amp;</span> <span class="n">kvs</span><span class="p">,</span> <span class="k">const</span> <span class="n">V</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>Get a key from a list of key-value pairs and its value.</p>
<h4>Function get_value()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">V</span> <span class="n">get_value</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;&amp;</span> <span class="n">kvs</span><span class="p">,</span> <span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
</code></pre></div>


<p>Get a value from a list of key-value pairs and its key.</p>
<h4>Function find()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Find the position of a value in an array. Returns -1 if not found.
Wrapper for std::find().</p>
<h4>Function upper_bound()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="n">upper_bound</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Find the first array value that is greater than the argument.
Assumes that the array is sorted. Wrapper for std::upper_bound().</p>
<h4>Function lower_bound()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="n">lower_bound</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Find the first array value smaller that is greater or equal to the argument.
Assumes that the array is sorted. Wrapper for std::lower_bound().</p>
<h4>Function contains()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Checks if a containers contains a value.</p>
<h4>Function contains()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Checks if a containers contains a value.</p>
<h4>Function contains()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Checks if a containers contains a value.</p>
<h4>Function contains()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Checks if a containers contains a value.</p>
<h4>Function contains()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Checks if a containers contains a value.</p>
<h4>Function contains()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="p">,</span> <span class="k">typename</span> <span class="n">K1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">K1</span><span class="o">&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Checks if a containers contains a value.</p>
<h4>Function contains()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="p">,</span> <span class="k">typename</span> <span class="n">K1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">K1</span><span class="o">&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Checks if a containers contains a value.</p>
<h4>Function enum_names()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;&amp;</span> <span class="n">enum_names</span><span class="p">();</span>
</code></pre></div>


<p>Names of enum values. Specialized by enums that support reflection.</p>
<h4>Function enum_names()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;&amp;</span> <span class="n">enum_names</span><span class="p">(</span><span class="n">T</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>Names of enum values.</p>
<h4>Function operator&lt;&lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
    <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_enum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Stream write.</p>
<h4>Function operator>>()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
    <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_enum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Stream read.</p>
<h4>Enum visit_var_type</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">visit_var_type</span> <span class="p">{</span>
    <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">path</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">object</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">reference</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">color</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">noneditable</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Types of variable semantic for <code>visit()</code>.</p>
<ul>
<li>Values:<ul>
<li>value:      Generic value.</li>
<li>name:      Name.</li>
<li>path:      Path.</li>
<li>object:      Object.</li>
<li>reference:      Reference.</li>
<li>color:      Color.</li>
<li>noneditable:      Generic value not editable.</li>
</ul>
</li>
</ul>
<h4>Struct visit_var</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">visit_var</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">visit_var_type</span> <span class="n">type</span> <span class="o">=</span> <span class="n">visit_var_type</span><span class="o">::</span><span class="n">value</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">help</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">short_name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Variable description for reflected values in <code>visit()</code>.</p>
<ul>
<li>Members:<ul>
<li>name:      Name.</li>
<li>type:      Type.</li>
<li>help:      Help.</li>
<li>min:      Minimum value for numeric types.</li>
<li>max:      Maximum value for numeric types.</li>
<li>short_name:      Short name</li>
</ul>
</li>
</ul>
<h4>Struct has_visitor</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">has_visitor</span> <span class="p">:</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span> <span class="p">{};</span>
</code></pre></div>


<p>Type trait to enable visitors.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements. Calls <code>visitor(name,val.var,sem)</code> for each variable
of a structure, where <code>name</code> is the name of the variable, <code>var</code> is the
variable and <code>sem</code> is one a <code>visit_sem</code> value.
Implemented by structures that support reflection.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">T</span><span class="o">*&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit pointer elements.</p>
<h4>Function operator&lt;&lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">has_visitor</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Stream write.</p>
<p><a id="toc37"></a></p>
<h3>Geometry utilities</h3>
<h4>Function line_tangent()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">line_tangent</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">);</span>
</code></pre></div>


<p>Line tangent.</p>
<h4>Function line_length()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">line_length</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">);</span>
</code></pre></div>


<p>Line length.</p>
<h4>Function triangle_normal()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">triangle_normal</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">);</span>
</code></pre></div>


<p>Triangle normal.</p>
<h4>Function triangle_area()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">triangle_area</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">);</span>
</code></pre></div>


<p>Triangle area.</p>
<h4>Function quad_normal()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">quad_normal</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v3</span><span class="p">);</span>
</code></pre></div>


<p>Quad normal.</p>
<h4>Function quad_area()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">quad_area</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v3</span><span class="p">);</span>
</code></pre></div>


<p>Quad area.</p>
<h4>Function tetrahedron_volume()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">tetrahedron_volume</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v3</span><span class="p">);</span>
</code></pre></div>


<p>tetrahedron volume</p>
<h4>Function triangle_tangents_fromuv()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="p">,</span> <span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">triangle_tangents_fromuv</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">uv0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">uv1</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">uv2</span><span class="p">);</span>
</code></pre></div>


<p>Triangle tangent and bitangent from uv (not othornormalized with themselfves
not the normal). Follows the definition in
http://www.terathon.com/code/tangent.html and
https://gist.github.com/aras-p/2843984</p>
<h4>Function interpolate_point()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">interpolate_point</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vals</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">);</span>
</code></pre></div>


<p>Copies of point value. Here only for completeness.</p>
<h4>Function interpolate_line()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">interpolate_line</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T1</span> <span class="n">u</span><span class="p">);</span>
</code></pre></div>


<p>Interpolates values over a line parametrized from a to b by u. Same as lerp.</p>
<h4>Function interpolate_line()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">interpolate_line</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vals</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">l</span><span class="p">,</span> <span class="n">T1</span> <span class="n">u</span><span class="p">);</span>
</code></pre></div>


<p>Interpolates values over lines parametrized from a to b by u. Same as lerp.</p>
<h4>Function interpolate_triangle()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">interpolate_triangle</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">uv</span><span class="p">);</span>
</code></pre></div>


<p>Interpolates values over a triangle parametrized by u and v along the
(v1-v0) and (v2-v0) directions. Same as barycentric interpolation.</p>
<h4>Function interpolate_triangle()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">interpolate_triangle</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vals</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">uv</span><span class="p">);</span>
</code></pre></div>


<p>Interpolates values over triangles parametrized by u and v along the
(v1-v0) and (v2-v0) directions. Same as barycentric interpolation.</p>
<h4>Function interpolate_triangle()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">interpolate_triangle</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v3</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">uv</span><span class="p">);</span>
</code></pre></div>


<p>Interpolates values over a quad parametrized by u and v along the
(v1-v0) and (v2-v1) directions. Same as bilear interpolation.</p>
<h4>Function interpolate_quad()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">interpolate_quad</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vals</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">uv</span><span class="p">);</span>
</code></pre></div>


<p>Interpolates values over quads parametrized by u and v along the
(v1-v0) and (v2-v1) direction. Same as bilear interpolation.</p>
<h4>Function eval_bernstein()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">eval_bernstein</span><span class="p">(</span><span class="n">T</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degree</span><span class="p">);</span>
</code></pre></div>


<p>Evaluates the i-th Bernstein polynomial of degree degree at u.</p>
<h4>Function eval_bernstein_derivative()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">eval_bernstein_derivative</span><span class="p">(</span><span class="n">T</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degree</span><span class="p">);</span>
</code></pre></div>


<p>Evaluates the derivative of i-th Bernstein polynomial of degree degree at u.</p>
<h4>Function interpolate_bezier()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">interpolate_bezier</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v3</span><span class="p">,</span> <span class="n">T1</span> <span class="n">u</span><span class="p">);</span>
</code></pre></div>


<p>Interpolates values along a cubic Bezier segment parametrized by u.</p>
<h4>Function interpolate_bezier()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">interpolate_bezier</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vals</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">T1</span> <span class="n">u</span><span class="p">);</span>
</code></pre></div>


<p>Interpolates values along cubic Bezier segments parametrized by u.</p>
<h4>Function interpolate_bezier_derivative()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">interpolate_bezier_derivative</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v3</span><span class="p">,</span> <span class="n">T1</span> <span class="n">u</span><span class="p">);</span>
</code></pre></div>


<p>Computes the derivative of a cubic Bezier segment parametrized by u.</p>
<h4>Function interpolate_bezier_derivative()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">interpolate_bezier_derivative</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vals</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">T1</span> <span class="n">u</span><span class="p">);</span>
</code></pre></div>


<p>Computes the derivative of a cubic Bezier segments parametrized by u.</p>
<p><a id="toc38"></a></p>
<h3>Animation utilities</h3>
<h4>Function eval_keyframed_step()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">eval_keyframed_step</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">times</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vals</span><span class="p">,</span> <span class="kt">float</span> <span class="n">time</span><span class="p">);</span>
</code></pre></div>


<p>Evalautes a keyframed value using step interpolation.</p>
<h4>Function eval_keyframed_linear()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">eval_keyframed_linear</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">times</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vals</span><span class="p">,</span> <span class="kt">float</span> <span class="n">time</span><span class="p">);</span>
</code></pre></div>


<p>Evalautes a keyframed value using linear interpolation.</p>
<h4>Function eval_keyframed_bezier()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">eval_keyframed_bezier</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">times</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vals</span><span class="p">,</span> <span class="kt">float</span> <span class="n">time</span><span class="p">);</span>
</code></pre></div>


<p>Evalautes a keyframed value using Bezier interpolation.</p>
<p><a id="toc39"></a></p>
<h3>Shape utilities</h3>
<h4>Function compute_tangents()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">compute_tangents</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">tang</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">weighted</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Compute per-vertex tangents for lines.</p>
<h4>Function compute_normals()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">compute_normals</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">weighted</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Compute per-vertex normals for triangles.</p>
<h4>Function compute_normals()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">compute_normals</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">weighted</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Compute per-vertex normals for quads.</p>
<h4>Function compute_tangent_frames()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">compute_tangent_frames</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;&amp;</span> <span class="n">tangsp</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">weighted</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Compute per-vertex tangent frames for triangle meshes.
Tangent space is defined by a four component vector.
The first three components are the tangent with respect to the u texcoord.
The fourth component is the sign of the tangent wrt the v texcoord.
Tangent frame is useful in normal mapping.</p>
<h4>Function compute_skinning()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">compute_skinning</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;&amp;</span> <span class="n">weights</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">joints</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">mat4f</span><span class="o">&gt;&amp;</span> <span class="n">xforms</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">skinned_pos</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">skinned_norm</span><span class="p">);</span>
</code></pre></div>


<p>Apply skinning to vertex position and normals.</p>
<h4>Function compute_skinning()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">compute_skinning</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;&amp;</span> <span class="n">weights</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">joints</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">frame3f</span><span class="o">&gt;&amp;</span> <span class="n">xforms</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">skinned_pos</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">skinned_norm</span><span class="p">);</span>
</code></pre></div>


<p>Apply skinning.</p>
<h4>Function compute_matrix_skinning()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">compute_matrix_skinning</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;&amp;</span> <span class="n">weights</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">joints</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">mat4f</span><span class="o">&gt;&amp;</span> <span class="n">xforms</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">skinned_pos</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">skinned_norm</span><span class="p">);</span>
</code></pre></div>


<p>Apply skinning as specified in Khronos glTF.</p>
<h4>Function get_edges()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;</span> <span class="n">get_edges</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">);</span>
</code></pre></div>


<p>Create an array of edges.</p>
<h4>Function convert_quads_to_triangles()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span> <span class="n">convert_quads_to_triangles</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">);</span>
</code></pre></div>


<p>Convert quads to triangles</p>
<h4>Function convert_quads_to_triangles()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span> <span class="n">convert_quads_to_triangles</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row_length</span><span class="p">);</span>
</code></pre></div>


<p>Convert quads to triangles with a diamond-like topology.
Quads have to be consecutive one row after another.</p>
<h4>Function convert_bezier_to_lines()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;</span> <span class="n">convert_bezier_to_lines</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">beziers</span><span class="p">);</span>
</code></pre></div>


<p>Convert beziers to lines using 3 lines for each bezier.</p>
<h4>Function convert_face_varying()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&gt;</span>
<span class="n">convert_face_varying</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads_pos</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads_norm</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads_texcoord</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">);</span>
</code></pre></div>


<p>Convert face-varying data to single primitives. Returns the quads indices
and filled vectors for pos, norm and texcoord.</p>
<h4>Function subdivide_lines()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">subdivide_lines</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vert</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">update_lines</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Subdivide lines by splitting each line in half.</p>
<h4>Function subdivide_lines()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">subdivide_lines</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">tang</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;&amp;</span> <span class="n">color</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">);</span>
</code></pre></div>


<p>Subdivide lines by splitting each line in half.</p>
<h4>Function subdivide_triangles()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">subdivide_triangles</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vert</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">update_triangles</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Subdivide triangle by splitting each triangle in four, creating new
vertices for each edge.</p>
<h4>Function subdivide_triangles()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">subdivide_triangles</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;&amp;</span> <span class="n">color</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">);</span>
</code></pre></div>


<p>Subdivide triangle by splitting each triangle in four, creating new
vertices for each edge.</p>
<h4>Function subdivide_quads()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">subdivide_quads</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vert</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">update_quads</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Subdivide quads by splitting each quads in four, creating new
vertices for each edge and for each face.</p>
<h4>Function subdivide_quads()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">subdivide_quads</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;&amp;</span> <span class="n">color</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">);</span>
</code></pre></div>


<p>Subdivide quads by splitting each quads in four, creating new
vertices for each edge and for each face.</p>
<h4>Function subdivide_beziers()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">subdivide_beziers</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">beziers</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vert</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">update_beziers</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Subdivide beziers by splitting each segment in two.</p>
<h4>Function subdivide_beziers()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">subdivide_beziers</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">beziers</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">tang</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;&amp;</span> <span class="n">color</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">);</span>
</code></pre></div>


<p>Subdivide beziers by splitting each segment in two.</p>
<h4>Function subdivide_catmullclark()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">subdivide_catmullclark</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">beziers</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vert</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">update_quads</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Subdivide quads using Carmull-Clark subdivision rules.</p>
<h4>Function subdivide_catmullclark()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">subdivide_catmullclark</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">tang</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;&amp;</span> <span class="n">color</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">);</span>
</code></pre></div>


<p>Subdivide quads using Carmull-Clark subdivision rules.</p>
<h4>Function make_quads_uv()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">make_quads_uv</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">uvs</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">usteps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vsteps</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">uwrap</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">vwrap</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">vpole0</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">vpole1</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Generate a rectangular grid of usteps x vsteps uv values for parametric
surface generation. Values cam wrap and have poles.points</p>
<h4>Function make_lines_uv()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">make_lines_uv</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">uvs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">usteps</span><span class="p">);</span>
</code></pre></div>


<p>Generate parametric num lines of usteps segments.</p>
<h4>Function make_points_uv()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">make_points_uv</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">points</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">uvs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</code></pre></div>


<p>Generate a parametric point set. Mostly here for completeness.</p>
<h4>Function make_quads()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">make_quads</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vert</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">usteps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vsteps</span><span class="p">,</span> <span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">vert_cb</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">uwrap</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">vwrap</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">vpole0</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">vpole1</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Generate a rectangular grid of usteps x vsteps uv values for parametric
surface generation. Values cam wrap and have poles.</p>
<h4>Function make_lines()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">make_lines</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vert</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">usteps</span><span class="p">,</span> <span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">vert_cb</span><span class="p">);</span>
</code></pre></div>


<p>Generate parametric num lines of usteps segments.</p>
<h4>Function make_points()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">make_points</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">points</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vert</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">vert_cb</span><span class="p">);</span>
</code></pre></div>


<p>Generate a parametric point set. Mostly here for completeness.</p>
<h4>Function make_quads()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">make_quads</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span> <span class="kt">int</span> <span class="n">usteps</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">vsteps</span><span class="p">,</span> <span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">vert_cb</span><span class="p">);</span>
</code></pre></div>


<p>Generate a rectangular grid of usteps x vsteps uv with callbacks for
position, normal and texcoord.</p>
<h4>Function make_lines()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">make_lines</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">usteps</span><span class="p">,</span> <span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">vert_cb</span><span class="p">);</span>
</code></pre></div>


<p>Generate parametric num lines of usteps segments with callbacks for
position, tangent, texcoord, and radius.</p>
<h4>Function make_points()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">make_points</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">points</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">vert_cb</span><span class="p">);</span>
</code></pre></div>


<p>Generate a parametric point set with callbacks for position, tangent,
texcoord, and radius.</p>
<h4>Function merge_lines()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">merge_lines</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines1</span><span class="p">);</span>
</code></pre></div>


<p>Merge lines between shapes. The elements are merged by increasing the
array size of the second array by the number of vertices of the first.
Vertex data can then be concatenated successfully.</p>
<h4>Function merge_triangles()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">merge_triangles</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles1</span><span class="p">);</span>
</code></pre></div>


<p>Merge triangles between shapes. The elements are merged by increasing the
array size of the second array by the number of vertices of the first.
Vertex data can then be concatenated successfully.</p>
<h4>Function merge_quads()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">merge_quads</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads1</span><span class="p">);</span>
</code></pre></div>


<p>Merge quads between shapes. The elements are merged by increasing the
array size of the second array by the number of vertices of the first.
Vertex data can then be concatenated successfully.</p>
<h4>Function merge_quads()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">merge_quads</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads1</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos1</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm1</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord1</span><span class="p">);</span>
</code></pre></div>


<p>Merge quads between shapes.</p>
<h4>Function facet_lines()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">facet_lines</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vert</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upgrade_lines</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Duplicate vertex data for each line index, giving a faceted look.</p>
<h4>Function facet_lines()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">facet_lines</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;&amp;</span> <span class="n">color</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">);</span>
</code></pre></div>


<p>Duplicate vertex data for each line index, giving a faceted look.</p>
<h4>Function facet_triangles()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">facet_triangles</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vert</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">upgrade_triangles</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Duplicate vertex data for each triangle index, giving a faceted look.</p>
<h4>Function facet_triangles()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">facet_triangles</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;&amp;</span> <span class="n">color</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">);</span>
</code></pre></div>


<p>Duplicate vertex data for each triangle index, giving a faceted look.</p>
<h4>Function facet_quads()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">facet_quads</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vert</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">upgrade_quads</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Duplicate vertex data for each quad index, giving a faceted look.</p>
<h4>Function facet_quads()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">facet_quads</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;&amp;</span> <span class="n">color</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">);</span>
</code></pre></div>


<p>Duplicate vertex data for each quad index, giving a faceted look.</p>
<p><a id="toc40"></a></p>
<h3>Shape sampling</h3>
<h4>Function sample_points()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sample_points</span><span class="p">(</span><span class="kt">int</span> <span class="n">npoints</span><span class="p">,</span> <span class="kt">float</span> <span class="n">re</span><span class="p">);</span>
</code></pre></div>


<p>Pick a point.</p>
<h4>Function sample_points_cdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">sample_points_cdf</span><span class="p">(</span><span class="kt">int</span> <span class="n">npoints</span><span class="p">);</span>
</code></pre></div>


<p>Compute a distribution for sampling points uniformly.</p>
<h4>Function sample_points()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sample_points</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">cdf</span><span class="p">,</span> <span class="kt">float</span> <span class="n">re</span><span class="p">);</span>
</code></pre></div>


<p>Pick a point uniformly.</p>
<h4>Function sample_lines_cdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">sample_lines_cdf</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">);</span>
</code></pre></div>


<p>Compute a distribution for sampling lines uniformly.</p>
<h4>Function sample_lines()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span> <span class="n">sample_lines</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">cdf</span><span class="p">,</span> <span class="kt">float</span> <span class="n">re</span><span class="p">,</span> <span class="kt">float</span> <span class="n">ru</span><span class="p">);</span>
</code></pre></div>


<p>Pick a point on lines uniformly.</p>
<h4>Function sample_triangles_cdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">sample_triangles_cdf</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">);</span>
</code></pre></div>


<p>Compute a distribution for sampling triangle meshes uniformly.</p>
<h4>Function sample_triangles()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vec2f</span><span class="o">&gt;</span> <span class="n">sample_triangles</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">cdf</span><span class="p">,</span> <span class="kt">float</span> <span class="n">re</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">ruv</span><span class="p">);</span>
</code></pre></div>


<p>Pick a point on a triangle mesh uniformly.</p>
<h4>Function sample_quads_cdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">sample_quads_cdf</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">);</span>
</code></pre></div>


<p>Compute a distribution for sampling quad meshes uniformly.</p>
<h4>Function sample_quads()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vec2f</span><span class="o">&gt;</span> <span class="n">sample_quads</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">cdf</span><span class="p">,</span> <span class="kt">float</span> <span class="n">re</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">ruv</span><span class="p">);</span>
</code></pre></div>


<p>Pick a point on a quad mesh uniformly.</p>
<h4>Function sample_triangles_points()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&gt;</span>
<span class="n">sample_triangles_points</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span> <span class="kt">int</span> <span class="n">npoints</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div>


<p>Samples a set of points over a triangle mesh uniformly. Returns pos, norm
and tecoord of the sampled points.</p>
<p><a id="toc41"></a></p>
<h3>Example shapes</h3>
<h4>Function make_sphere()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">make_sphere</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tesselation</span><span class="p">);</span>
</code></pre></div>


<p>Make a sphere.</p>
<h4>Function make_geodesicsphere()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">make_geodesicsphere</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tesselation</span><span class="p">);</span>
</code></pre></div>


<p>Make a geodesic sphere.</p>
<h4>Function make_cube()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">make_cube</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tesselation</span><span class="p">);</span>
</code></pre></div>


<p>Make a cube with unique vertices. This is watertight but has no
texture coordinates or normals.</p>
<h4>Function make_uvsphere()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">make_uvsphere</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tesselation</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">flipped</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Make a sphere. This is not watertight.</p>
<h4>Function make_uvhemisphere()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">make_uvhemisphere</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tesselation</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">flipped</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Make a sphere. This is not watertight.</p>
<h4>Function make_uvquad()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">make_uvquad</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tesselation</span><span class="p">);</span>
</code></pre></div>


<p>Make a quad.</p>
<h4>Function make_fvsphere()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">make_fvsphere</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads_pos</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads_norm</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads_texcoord</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">tesselation</span><span class="p">);</span>
</code></pre></div>


<p>Make a facevarying sphere with unique vertices but different texture
coordinates.</p>
<h4>Function make_fvcube()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">make_fvcube</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads_pos</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads_norm</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads_texcoord</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">tesselation</span><span class="p">);</span>
</code></pre></div>


<p>Make a facevarying cube with unique vertices but different texture
coordinates.</p>
<h4>Function make_suzanne()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">make_suzanne</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tesselation</span><span class="p">);</span>
</code></pre></div>


<p>Make a suzanne monkey model for testing. Note that some quads are
degenerate. Returns quads, pos.</p>
<h4>Function make_uvcube()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">make_uvcube</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tesselation</span><span class="p">);</span>
</code></pre></div>


<p>Make a cube. This is not watertight.</p>
<h4>Function make_uvspherecube()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">make_uvspherecube</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tesselation</span><span class="p">);</span>
</code></pre></div>


<p>Make a sphere from a cube. This is not watertight.</p>
<h4>Function make_uvspherizedcube()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">make_uvspherizedcube</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tesselation</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">radius</span><span class="p">);</span>
</code></pre></div>


<p>Make a cube than stretch it towards a sphere. This is not watertight.</p>
<h4>Function make_uvflipcapsphere()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">make_uvflipcapsphere</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tesselation</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">z</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">flipped</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Make a sphere with caps flipped. This is not watertight.</p>
<h4>Function make_uvcutsphere()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">make_uvcutsphere</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tesselation</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">z</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">flipped</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Make a cutout sphere. This is not watertight.</p>
<h4>Struct make_seashell_params</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">make_seashell_params</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">spiral_revolutions</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">spiral_angle</span> <span class="o">=</span> <span class="mi">83</span> <span class="o">*</span> <span class="n">pif</span> <span class="o">/</span> <span class="mi">180</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">enlarging_angle</span> <span class="o">=</span> <span class="mi">42</span> <span class="o">*</span> <span class="n">pif</span> <span class="o">/</span> <span class="mi">180</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">spiral_aperture</span> <span class="o">=</span> <span class="mf">0.25f</span><span class="p">;</span>
    <span class="n">vec2f</span> <span class="n">ellipse_axis</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.12f</span><span class="p">,</span> <span class="mf">0.20f</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">curve_rotation</span> <span class="o">=</span> <span class="p">{</span><span class="mi">70</span> <span class="o">*</span> <span class="n">pif</span> <span class="o">/</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">30</span> <span class="o">*</span> <span class="n">pif</span> <span class="o">/</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">pif</span> <span class="o">/</span> <span class="mi">180</span><span class="p">};</span>
    <span class="kt">float</span> <span class="n">nodules_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">vec2f</span> <span class="n">nodule_length</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="kt">float</span> <span class="n">nodule_height</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">nodule_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Make seashell params</p>
<ul>
<li>Members:<ul>
<li>spiral_revolutions:      Spiral revolutions.</li>
<li>spiral_angle:      Spiral angle (alpha) in [0,pi].</li>
<li>enlarging_angle:      Enlarging revolutions (beta) in [0,2pi].</li>
<li>spiral_aperture:      Spiral aperture (A) in [0,inf].</li>
<li>ellipse_axis:      Ellipse axis (a,b) in [0,inf].</li>
<li>curve_rotation:      Curve rotatation (psi, Omega, mu) in [0,2pi].</li>
<li>nodules_num:      Number of nodules (N) in [0,ing].</li>
<li>nodule_length:      Length of nodules along curve and spiral (W1,W2) in [0,inf].</li>
<li>nodule_height:      Height of nodules (L) in [0,inf].</li>
<li>nodule_pos:      Position of nodules (P) in [0,inf].</li>
</ul>
</li>
</ul>
<h4>Function make_uvseashell()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">make_uvseashell</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tesselation</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">make_seashell_params</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">);</span>
</code></pre></div>


<p>Make a seashell. This is not watertight. Returns quads, pos, norm, texcoord.</p>
<h4>Function make_bezier_circle()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">make_bezier_circle</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">beziers</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">);</span>
</code></pre></div>


<p>Make a bezier circle. Returns bezier, pos.</p>
<h4>Struct make_hair_params</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">make_hair_params</span> <span class="p">{</span>
    <span class="n">vec2f</span> <span class="n">length</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.1f</span><span class="p">,</span> <span class="mf">0.1f</span><span class="p">};</span>
    <span class="n">vec2f</span> <span class="n">radius</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.005f</span><span class="p">,</span> <span class="mf">0.001f</span><span class="p">};</span>
    <span class="n">vec2f</span> <span class="n">noise</span> <span class="o">=</span> <span class="n">zero2f</span><span class="p">;</span>
    <span class="n">vec2f</span> <span class="n">clump</span> <span class="o">=</span> <span class="n">zero2f</span><span class="p">;</span>
    <span class="n">vec2f</span> <span class="n">rotation</span> <span class="o">=</span> <span class="n">zero2f</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Parameters for the make hair function</p>
<ul>
<li>Members:<ul>
<li>length:      minimum and maximum length</li>
<li>radius:      minimum and maximum radius from base to tip</li>
<li>noise:      noise added to hair (strength/scale)</li>
<li>clump:      clump added to hair (number/strength)</li>
<li>rotation:      rotation</li>
<li>seed:      random seed</li>
</ul>
</li>
</ul>
<h4>Function make_hair()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">make_hair</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">tang</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tesselation</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">striangles</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">squads</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">spos</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">snorm</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">stexcoord</span><span class="p">,</span> <span class="k">const</span> <span class="n">make_hair_params</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">);</span>
</code></pre></div>


<p>Make a hair ball around a shape.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">make_hair_params</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<p><a id="toc42"></a></p>
<h3>Image containers</h3>
<h4>Struct image</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">image</span> <span class="p">{</span>
    <span class="n">image</span><span class="p">();</span> 
    <span class="n">image</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span> <span class="o">=</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="nf">width</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="nf">height</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">T</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">pixels</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Generic image container. Access pixels with at() or operator [].</p>
<ul>
<li>Members:<ul>
<li>image():      empty image constructor</li>
<li>image():      image constructor</li>
<li>width():      width</li>
<li>height():      height</li>
<li>empty():      check for empty</li>
<li>at():      Element access</li>
<li>at():      Element access</li>
<li>h:      Width and height [private].</li>
<li>pixels:      Pixels [private].</li>
</ul>
</li>
</ul>
<h4>Typedef image4f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">image4f</span> <span class="o">=</span> <span class="n">image</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>HDR image</p>
<h4>Typedef image4b</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">image4b</span> <span class="o">=</span> <span class="n">image</span><span class="o">&lt;</span><span class="n">vec4b</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>LDR image</p>
<h4>Function begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span><span class="o">*</span> <span class="n">begin</span><span class="p">(</span><span class="n">image</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Pixel iteration.</p>
<h4>Function begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">begin</span><span class="p">(</span><span class="k">const</span> <span class="n">image</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Pixel iteration.</p>
<h4>Function end()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span><span class="o">*</span> <span class="n">end</span><span class="p">(</span><span class="n">image</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Pixel iteration.</p>
<h4>Function end()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">end</span><span class="p">(</span><span class="k">const</span> <span class="n">image</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Pixel iteration.</p>
<h4>Function data()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span><span class="o">*</span> <span class="n">data</span><span class="p">(</span><span class="n">image</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Pixel access.</p>
<h4>Function data()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">data</span><span class="p">(</span><span class="k">const</span> <span class="n">image</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Pixel access.</p>
<h4>Function size()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="n">size</span><span class="p">(</span><span class="n">image</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Number of pixels.</p>
<h4>Function empty()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">(</span><span class="n">image</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Chech if an image is empty.</p>
<h4>Function make_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">image</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">make_image</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">vals</span><span class="p">);</span>
</code></pre></div>


<p>Create an image with values stored in an array in scanliine order.</p>
<h4>Function make_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">image</span><span class="o">&lt;</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&gt;</span> <span class="n">make_image</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nc</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">vals</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">def</span><span class="p">);</span>
</code></pre></div>


<p>Create a 4 channel image with the given number of channels</p>
<p><a id="toc43"></a></p>
<h3>Image operations</h3>
<h4>Function srgb_to_linear()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="nf">srgb_to_linear</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4b</span><span class="o">&amp;</span> <span class="n">srgb</span><span class="p">);</span>
</code></pre></div>


<p>Approximate conversion from srgb.</p>
<h4>Function linear_to_srgb()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4b</span> <span class="nf">linear_to_srgb</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">lin</span><span class="p">);</span>
</code></pre></div>


<p>Approximate conversion to srgb.</p>
<h4>Function xyz_to_xyY()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">xyz_to_xyY</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">xyz</span><span class="p">);</span>
</code></pre></div>


<p>Convert between CIE XYZ and xyY</p>
<h4>Function xyY_to_xyz()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">xyY_to_xyz</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">xyY</span><span class="p">);</span>
</code></pre></div>


<p>Convert between CIE XYZ and xyY</p>
<h4>Function xyz_to_rgb()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">xyz_to_rgb</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">xyz</span><span class="p">);</span>
</code></pre></div>


<p>Convert between CIE XYZ and RGB</p>
<h4>Function rgb_to_xyz()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">rgb_to_xyz</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">rgb</span><span class="p">);</span>
</code></pre></div>


<p>Convert between CIE XYZ and RGB</p>
<h4>Function tonemap_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4b</span> <span class="nf">tonemap_image</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">hdr</span><span class="p">,</span> <span class="kt">float</span> <span class="n">exposure</span><span class="p">,</span> <span class="kt">float</span> <span class="n">gamma</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">filmic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Tone mapping HDR to LDR images.</p>
<h4>Function image_over()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">image_over</span><span class="p">(</span><span class="n">vec4f</span><span class="o">*</span> <span class="n">img</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nlayers</span><span class="p">,</span> <span class="n">vec4f</span><span class="o">**</span> <span class="n">layers</span><span class="p">);</span>
</code></pre></div>


<p>Image over operator.</p>
<h4>Function image_over()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">image_over</span><span class="p">(</span><span class="n">vec4b</span><span class="o">*</span> <span class="n">img</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nlayers</span><span class="p">,</span> <span class="n">vec4b</span><span class="o">**</span> <span class="n">layers</span><span class="p">);</span>
</code></pre></div>


<p>Image over operator.</p>
<h4>Function hsv_to_rgb()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec4b</span> <span class="nf">hsv_to_rgb</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4b</span><span class="o">&amp;</span> <span class="n">hsv</span><span class="p">);</span>
</code></pre></div>


<p>Converts HSV to RGB.</p>
<p><a id="toc44"></a></p>
<h3>Example images</h3>
<h4>Function make_grid_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4b</span> <span class="n">make_grid_image</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tile</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec4b</span><span class="o">&amp;</span> <span class="n">c0</span> <span class="o">=</span><span class="p">;</span>
</code></pre></div>


<p>Make a grid image.</p>
<h4>Function make_checker_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4b</span> <span class="n">make_checker_image</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tile</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec4b</span><span class="o">&amp;</span> <span class="n">c0</span> <span class="o">=</span><span class="p">;</span>
</code></pre></div>


<p>Make a checkerboard image.</p>
<h4>Function make_bumpdimple_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4b</span> <span class="nf">make_bumpdimple_image</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tile</span> <span class="o">=</span> <span class="mi">64</span><span class="p">);</span>
</code></pre></div>


<p>Make an image with bumps and dimples.</p>
<h4>Function make_ramp_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4b</span> <span class="nf">make_ramp_image</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4b</span><span class="o">&amp;</span> <span class="n">c0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4b</span><span class="o">&amp;</span> <span class="n">c1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">srgb</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Make a uv colored grid.</p>
<h4>Function make_gammaramp_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4b</span> <span class="nf">make_gammaramp_image</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">);</span>
</code></pre></div>


<p>Make a gamma ramp image.</p>
<h4>Function make_gammaramp_imagef()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4f</span> <span class="nf">make_gammaramp_imagef</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">);</span>
</code></pre></div>


<p>Make a gamma ramp image.</p>
<h4>Function make_uv_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4b</span> <span class="nf">make_uv_image</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">);</span>
</code></pre></div>


<p>Make an image color with red/green in the [0,1] range. Helpful to visualize
uv texture coordinate application.</p>
<h4>Function make_uvgrid_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4b</span> <span class="nf">make_uvgrid_image</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tile</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">colored</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Make a uv colored grid.</p>
<h4>Function make_recuvgrid_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4b</span> <span class="nf">make_recuvgrid_image</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tile</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">colored</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Make a uv recusive colored grid.</p>
<h4>Function bump_to_normal_map()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4b</span> <span class="nf">bump_to_normal_map</span><span class="p">(</span><span class="k">const</span> <span class="n">image4b</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span> <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Comvert a bump map to a normal map.</p>
<h4>Function make_sunsky_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4f</span> <span class="nf">make_sunsky_image</span><span class="p">(</span><span class="kt">int</span> <span class="n">res</span><span class="p">,</span> <span class="kt">float</span> <span class="n">thetaSun</span><span class="p">,</span> <span class="kt">float</span> <span class="n">turbidity</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">has_sun</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_ground</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Make a sunsky HDR model with sun at theta elevation in [0,pi/2], turbidity
in [1.7,10] with or without sun.</p>
<h4>Function make_noise_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4b</span> <span class="nf">make_noise_image</span><span class="p">(</span><span class="kt">int</span> <span class="n">resx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">resy</span><span class="p">,</span> <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">wrap</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Make a noise image. Wrap works only if both resx and resy are powers of two.</p>
<h4>Function make_fbm_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4b</span> <span class="nf">make_fbm_image</span><span class="p">(</span><span class="kt">int</span> <span class="n">resx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">resy</span><span class="p">,</span> <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">lacunarity</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="kt">float</span> <span class="n">gain</span> <span class="o">=</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">octaves</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">wrap</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Make a noise image. Wrap works only if both resx and resy are powers of two.</p>
<h4>Function make_ridge_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4b</span> <span class="nf">make_ridge_image</span><span class="p">(</span><span class="kt">int</span> <span class="n">resx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">resy</span><span class="p">,</span> <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">lacunarity</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="kt">float</span> <span class="n">gain</span> <span class="o">=</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="kt">float</span> <span class="n">offset</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">octaves</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">wrap</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Make a noise image. Wrap works only if both resx and resy are powers of two.</p>
<h4>Function make_turbulence_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4b</span> <span class="nf">make_turbulence_image</span><span class="p">(</span><span class="kt">int</span> <span class="n">resx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">resy</span><span class="p">,</span> <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">lacunarity</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="kt">float</span> <span class="n">gain</span> <span class="o">=</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">octaves</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">wrap</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Make a noise image. Wrap works only if both resx and resy are powers of two.</p>
<p><a id="toc45"></a></p>
<h3>Image loading and saving</h3>
<h4>Function is_hdr_filename()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">is_hdr_filename</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>
</code></pre></div>


<p>Check if an image is HDR based on filename.</p>
<h4>Function load_image4b()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4b</span> <span class="nf">load_image4b</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>
</code></pre></div>


<p>Loads a 4 channel ldr image.</p>
<h4>Function load_image4f()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4f</span> <span class="nf">load_image4f</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>
</code></pre></div>


<p>Loads a 4 channel hdr image.</p>
<h4>Function save_image4b()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">save_image4b</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">image4b</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">);</span>
</code></pre></div>


<p>Saves a 4 channel ldr image.</p>
<h4>Function save_image4f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">save_image4f</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">);</span>
</code></pre></div>


<p>Saves a 4 channel hdr image.</p>
<h4>Function load_imagef()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">load_imagef</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">ncomp</span><span class="p">);</span>
</code></pre></div>


<p>Loads an image with variable number of channels.</p>
<h4>Function load_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">byte</span><span class="o">&gt;</span> <span class="n">load_image</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">ncomp</span><span class="p">);</span>
</code></pre></div>


<p>Loads an image with variable number of channels.</p>
<h4>Function load_imagef_from_memory()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">load_imagef_from_memory</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">byte</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">ncomp</span><span class="p">);</span>
</code></pre></div>


<p>Loads an image from memory with variable number of channels.</p>
<h4>Function load_image_from_memory()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">byte</span><span class="o">&gt;</span> <span class="n">load_image_from_memory</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">byte</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">ncomp</span><span class="p">);</span>
</code></pre></div>


<p>Loads an image from memory with variable number of channels.</p>
<h4>Function save_imagef()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">save_imagef</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncomp</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">hdr</span><span class="p">);</span>
</code></pre></div>


<p>Saves an image with variable number of channels.</p>
<h4>Function save_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">save_image</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncomp</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">byte</span><span class="o">*</span> <span class="n">ldr</span><span class="p">);</span>
</code></pre></div>


<p>Saves an image with variable number of channels.</p>
<h4>Function save_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">save_image</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">hdr</span><span class="p">,</span> <span class="kt">float</span> <span class="n">exposure</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">gamma</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">filmic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Save a 4 channel HDR or LDR image with tonemapping based on filename.</p>
<h4>Enum resize_filter</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">resize_filter</span> <span class="p">{</span>
    <span class="n">def</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">box</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">triangle</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">cubic_spline</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">catmull_rom</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">mitchell</span> <span class="o">=</span> <span class="mi">5</span>

<span class="p">}</span>
</code></pre></div>


<p>Filter type for resizing.</p>
<ul>
<li>Values:<ul>
<li>def:      default</li>
<li>box:      box filter</li>
<li>triangle:      triangle filter</li>
<li>cubic_spline:      cubic spline</li>
<li>catmull_rom:      Catmull-Rom interpolating sline</li>
<li>mitchell:      Mitchel-Netrevalli filter with B=1/3, C=1/3</li>
</ul>
</li>
</ul>
<h4>Enum resize_edge</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">resize_edge</span> <span class="p">{</span>
    <span class="n">def</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">clamp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">reflect</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">wrap</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="mi">4</span>

<span class="p">}</span>
</code></pre></div>


<p>Edge mode for resizing.</p>
<ul>
<li>Values:<ul>
<li>def:      default</li>
<li>clamp:      clamp</li>
<li>reflect:      reflect</li>
<li>wrap:      wrap</li>
<li>zero:      zero</li>
</ul>
</li>
</ul>
<h4>Function resize_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">resize_image</span><span class="p">(</span><span class="k">const</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">res_img</span><span class="p">,</span>
    <span class="n">resize_filter</span> <span class="n">filter</span> <span class="o">=</span> <span class="n">resize_filter</span><span class="o">::</span><span class="n">def</span><span class="p">,</span>
    <span class="n">resize_edge</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">resize_edge</span><span class="o">::</span><span class="n">def</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">premultiplied_alpha</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Resize an image.</p>
<h4>Function resize_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">resize_image</span><span class="p">(</span><span class="k">const</span> <span class="n">image4b</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span> <span class="n">image4b</span><span class="o">&amp;</span> <span class="n">res_img</span><span class="p">,</span>
    <span class="n">resize_filter</span> <span class="n">filter</span> <span class="o">=</span> <span class="n">resize_filter</span><span class="o">::</span><span class="n">def</span><span class="p">,</span>
    <span class="n">resize_edge</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">resize_edge</span><span class="o">::</span><span class="n">def</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">premultiplied_alpha</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Resize an image.</p>
<p><a id="toc46"></a></p>
<h3>Ray-primitive intersection</h3>
<h4>Function intersect_point()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">intersect_point</span><span class="p">(</span><span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span> <span class="kt">float</span> <span class="n">r</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">ray_t</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a ray with a point (approximate).
Based on http://geomalgorithms.com/a02-lines.html.</p>
<h4>Function intersect_line()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">intersect_line</span><span class="p">(</span><span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">r0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">r1</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">ray_t</span><span class="p">,</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a ray with a line (approximate).
Based on http://geomalgorithms.com/a05-intersect-1.html and
http://geomalgorithms.com/a07-distance.html#
    dist3D_Segment_to_Segment</p>
<h4>Function intersect_triangle()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">intersect_triangle</span><span class="p">(</span><span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">ray_t</span><span class="p">,</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a ray with a triangle.</p>
<h4>Function intersect_quad()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">intersect_quad</span><span class="p">(</span><span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v3</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">ray_t</span><span class="p">,</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a ray with a quad represented as two triangles (0,1,3) and
(2,3,1), with the uv coordinates of the second triangle corrected by u =
1-u' and v = 1-v' to produce a quad parametrization where u and v go from 0
to 1. This is equivalent to Intel's Embree.</p>
<h4>Function intersect_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">intersect_bbox</span><span class="p">(</span><span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">bbox</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a ray with a axis-aligned bounding box.</p>
<h4>Function intersect_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">intersect_bbox</span><span class="p">(</span><span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ray_dinv</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">ray_dsign</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">bbox</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a ray with a axis-aligned bounding box, implemented as
"Robust BVH Ray Traversal" by T. Ize published at
http://jcgt.org/published/0002/02/02/paper.pdf</p>
<p><a id="toc47"></a></p>
<h3>Point-primitive overlap</h3>
<h4>Function overlap_point()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">overlap_point</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">float</span> <span class="n">dist_max</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">r0</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">dist</span><span class="p">);</span>
</code></pre></div>


<p>Check if a point overlaps a position within a max distance.</p>
<h4>Function closestuv_line()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">float</span> <span class="nf">closestuv_line</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">);</span>
</code></pre></div>


<p>Find closest line point to a position.</p>
<h4>Function overlap_line()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">overlap_line</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">float</span> <span class="n">dist_max</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">r0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">r1</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">dist</span><span class="p">,</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Check if a line overlaps a position within a max distance.</p>
<h4>Function closestuv_triangle()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec2f</span> <span class="nf">closestuv_triangle</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">);</span>
</code></pre></div>


<p>Find closest triangle point to a position.</p>
<h4>Function overlap_triangle()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">overlap_triangle</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">float</span> <span class="n">dist_max</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="kt">float</span> <span class="n">r0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">r1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">r2</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">dist</span><span class="p">,</span>
    <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Check if a triangle overlaps a position within a max distance.</p>
<h4>Function overlap_quad()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">overlap_quad</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">float</span> <span class="n">dist_max</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v3</span><span class="p">,</span> <span class="kt">float</span> <span class="n">r0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">r1</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">r2</span><span class="p">,</span> <span class="kt">float</span> <span class="n">r3</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">dist</span><span class="p">,</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Check if a quad overlaps a position within a max distance.</p>
<h4>Function overlap_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">overlap_bbox</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">float</span> <span class="n">dist_max</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">bbox</span><span class="p">);</span>
</code></pre></div>


<p>Check if a bouning box overlaps a position within a max distance.</p>
<h4>Function overlap_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">overlap_bbox</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">bbox1</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">bbox2</span><span class="p">);</span>
</code></pre></div>


<p>Check if two bouning boxes overlap.</p>
<p><a id="toc48"></a></p>
<h3>Bounding volume hierarchy</h3>
<h4>Enum bvh_node_type : uint32_t</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="nl">bvh_node_type</span> <span class="p">:</span> <span class="kt">uint32_t</span> <span class="p">{</span>
    <span class="n">internal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">point</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">line</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">triangle</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">quad</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">vertex</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
    <span class="n">instance</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Type of BVH node.</p>
<ul>
<li>Values:<ul>
<li>internal:      Internal.</li>
<li>point:      Points.</li>
<li>line:      Lines.</li>
<li>triangle:      Triangles.</li>
<li>quad:      Quads.</li>
<li>vertex:      Vertices.</li>
<li>instance:      Instances.</li>
</ul>
</li>
</ul>
<h4>Struct bvh_node</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">bvh_node</span> <span class="p">{</span>
    <span class="n">bbox3f</span> <span class="n">bbox</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">start</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">count</span><span class="p">;</span>
    <span class="n">bvh_node_type</span> <span class="n">type</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">axis</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>BVH tree node containing its bounds, indices to the BVH arrays of either
sorted primitives or internal nodes, the node element type,
and the split axis. Leaf and internal nodes are identical, except that
indices refer to primitives for leaf nodes or other nodes for internal
nodes. See bvh_tree for more details.
This is an internal data structure.</p>
<ul>
<li>Members:<ul>
<li>bbox:      Bounding box.</li>
<li>start:      Index to the first sorted primitive/node.</li>
<li>count:      Number of primitives/nodes.</li>
<li>type:      Type of node.</li>
<li>axis:      Slit axis for internal nodes.</li>
</ul>
</li>
</ul>
<h4>Struct bvh_instance</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">bvh_instance</span> <span class="p">{</span>
    <span class="n">frame3f</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">identity_frame3f</span><span class="p">;</span>
    <span class="n">frame3f</span> <span class="n">frame_inv</span> <span class="o">=</span> <span class="n">identity_frame3f</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">iid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">sid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Shape instance for two-level BVH.
This is an internal data structure.</p>
<ul>
<li>Members:<ul>
<li>frame:      Frame.</li>
<li>frame_inv:      Frame inverse.</li>
<li>iid:      Instance id to be returned.</li>
<li>sid:      Shape id to be returned.</li>
<li>bvh:      Shape bvh.</li>
</ul>
</li>
</ul>
<h4>Struct bvh_tree</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">bvh_tree</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">bvh_node</span><span class="o">&gt;</span> <span class="n">nodes</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sorted_prim</span><span class="p">;</span>
    <span class="n">bvh_node_type</span> <span class="n">type</span> <span class="o">=</span> <span class="n">bvh_node_type</span><span class="o">::</span><span class="n">internal</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">pos</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">radius</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;</span> <span class="n">lines</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span> <span class="n">triangles</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span> <span class="n">quads</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">bvh_instance</span><span class="o">&gt;</span> <span class="n">instances</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">bvh_tree</span><span class="o">*&gt;</span> <span class="n">shape_bvhs</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">own_shape_bvhs</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="o">~</span><span class="n">bvh_tree</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>BVH tree, stored as a node array. The tree structure is encoded using array
indices instead of pointers, both for speed but also to simplify code.
BVH nodes indices refer to either the node array, for internal nodes,
or a primitive array, for leaf nodes. BVH trees may contain only one type
of geometric primitive, like points, lines, triangle or instances of other
BVHs. To handle multiple primitive types and transformed primitives, build
a two-level hierarchy with the outer BVH, the scene BVH, containing inner
BVHs, shape BVHs, each of which of a uniform primitive type.
This is an internal data structure.</p>
<ul>
<li>Members:<ul>
<li>nodes:      Sorted array of internal nodes.</li>
<li>sorted_prim:      Sorted array of elements.</li>
<li>type:      Leaf element type.</li>
<li>pos:      Positions for shape BVHs.</li>
<li>radius:      Radius for shape BVHs.</li>
<li>points:      Points for shape BVHs.</li>
<li>lines:      Lines for shape BVHs.</li>
<li>triangles:      Triangles for shape BVHs.</li>
<li>quads:      Quads for shape BVHs.</li>
<li>instances:      Instance ids (iid, sid, shape bvh index).</li>
<li>shape_bvhs:      Shape BVHs.</li>
<li>own_shape_bvhs:      Whether it owns the memory of the shape BVHs.</li>
<li>~bvh_tree():      Cleanup.</li>
</ul>
</li>
</ul>
<h4>Function make_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">bvh_tree</span><span class="o">*</span> <span class="nf">make_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">points</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">,</span> <span class="kt">float</span> <span class="n">def_radius</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">equalsize</span><span class="p">);</span>
</code></pre></div>


<p>Build a shape BVH from a set of primitives.</p>
<h4>Function make_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">bvh_tree</span><span class="o">*</span> <span class="nf">make_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">bvh_instance</span><span class="o">&gt;&amp;</span> <span class="n">instances</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">bvh_tree</span><span class="o">*&gt;&amp;</span> <span class="n">shape_bvhs</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">own_shape_bvhs</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">equal_size</span><span class="p">);</span>
</code></pre></div>


<p>Build a scene BVH from a set of shape instances.</p>
<h4>Function get_shape_bvhs()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">bvh_tree</span><span class="o">*&gt;&amp;</span> <span class="n">get_shape_bvhs</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">);</span>
</code></pre></div>


<p>Grab the shape BVHs</p>
<h4>Function refit_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">refit_bvh</span><span class="p">(</span><span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">,</span> <span class="kt">float</span> <span class="n">def_radius</span><span class="p">);</span>
</code></pre></div>


<p>Update the node bounds for a shape bvh.</p>
<h4>Function refit_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">refit_bvh</span><span class="p">(</span><span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">frame3f</span><span class="o">&gt;&amp;</span> <span class="n">frames</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">frame3f</span><span class="o">&gt;&amp;</span> <span class="n">frames_inv</span><span class="p">);</span>
</code></pre></div>


<p>Update the node bounds for a scene bvh</p>
<h4>Function intersect_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">intersect_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">find_any</span><span class="p">,</span>
    <span class="kt">float</span><span class="o">&amp;</span> <span class="n">ray_t</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">iid</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">sid</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">,</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Intersect ray with a bvh returning either the first or any intersection
depending on <code>find_any</code>. Returns the ray distance <code>ray_t</code>, the instance
id <code>iid</code>, the shape id <code>sid</code>, the shape element index <code>eid</code> and the
shape barycentric coordinates <code>euv</code>.</p>
<h4>Function overlap_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">overlap_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_dist</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">find_any</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">dist</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">iid</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">sid</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">,</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Find a shape element that overlaps a point within a given distance
<code>max_dist</code>, returning either the closest or any overlap depending on
<code>find_any</code>. Returns the point distance <code>dist</code>, the instance id <code>iid</code>, the
shape id <code>sid</code>, the shape element index <code>eid</code> and the shape barycentric
coordinates <code>euv</code>.</p>
<h4>Struct intersection_point</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">intersection_point</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">iid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">sid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">eid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">vec2f</span> <span class="n">euv</span> <span class="o">=</span> <span class="n">zero2f</span><span class="p">;</span>
    <span class="k">operator</span> <span class="nf">bool</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div>


<p>Intersection point.</p>
<ul>
<li>Members:<ul>
<li>dist:      Distance of the hit along the ray or from the point.</li>
<li>iid:      Instance index.</li>
<li>sid:      Shape index.</li>
<li>eid:      Shape element index.</li>
<li>euv:      Shape barycentric coordinates.</li>
<li>operator bool():      Check if intersection is valid.</li>
</ul>
</li>
</ul>
<h4>Function intersect_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">intersection_point</span> <span class="nf">intersect_bvh</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a ray with a bvh (convenience wrapper).</p>
<h4>Function overlap_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">intersection_point</span> <span class="nf">overlap_bvh</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_dist</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">);</span>
</code></pre></div>


<p>Finds the closest element with a bvh (convenience wrapper).</p>
<p><a id="toc49"></a></p>
<h3>Simple scene</h3>
<h4>Struct camera</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">camera</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">frame3f</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">identity_frame3f</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">ortho</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">yfov</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">aspect</span> <span class="o">=</span> <span class="mf">16.0f</span> <span class="o">/</span> <span class="mf">9.0f</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">focus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">aperture</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">near</span> <span class="o">=</span> <span class="mf">0.01f</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">far</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Camera.</p>
<ul>
<li>Members:<ul>
<li>name:      Name.</li>
<li>frame:      Transform frame.</li>
<li>ortho:      Orthographic camera.</li>
<li>yfov:      Vertical field of view. </li>
<li>aspect:      Aspect ratio. </li>
<li>focus:      Focus distance. </li>
<li>aperture:      Lens aperture. </li>
<li>near:      Near plane distance. </li>
<li>far:      Far plane distance. </li>
</ul>
</li>
</ul>
<h4>Struct texture</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">texture</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">image4b</span> <span class="n">ldr</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">image4f</span> <span class="n">hdr</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>Texture containing either an LDR or HDR image.</p>
<ul>
<li>Members:<ul>
<li>name:      Name.</li>
<li>path:      Path.</li>
<li>ldr:      Ldr image.</li>
<li>hdr:      Hdr image.</li>
</ul>
</li>
</ul>
<h4>Struct texture_info</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">texture_info</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">wrap_s</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">wrap_t</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">linear</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">mipmap</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Texture information to use for lookup.</p>
<ul>
<li>Members:<ul>
<li>wrap_s:      Wrap s coordinate.</li>
<li>wrap_t:      Wrap t coordinate.</li>
<li>linear:      Linear interpolation.</li>
<li>mipmap:      Mipmaping.</li>
<li>scale:      Texture strength (occlusion and normal). </li>
</ul>
</li>
</ul>
<h4>Enum material_type</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">material_type</span> <span class="p">{</span>
    <span class="n">specular_roughness</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">metallic_roughness</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">specular_glossiness</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Material type.</p>
<ul>
<li>Values:<ul>
<li>specular_roughness:      Microfacet material type (OBJ).</li>
<li>metallic_roughness:      Base and metallic material (metallic-roughness in glTF).</li>
<li>specular_glossiness:      Diffuse and specular material (specular-glossness in glTF).</li>
</ul>
</li>
</ul>
<h4>Struct material</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">material</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">double_sided</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">material_type</span> <span class="n">type</span> <span class="o">=</span> <span class="n">material_type</span><span class="o">::</span><span class="n">specular_roughness</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">ke</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">kd</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">ks</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">kr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">kt</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="kt">float</span> <span class="n">rs</span> <span class="o">=</span> <span class="mf">0.0001</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">op</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">texture</span><span class="o">*</span> <span class="n">ke_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture</span><span class="o">*</span> <span class="n">kd_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture</span><span class="o">*</span> <span class="n">ks_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture</span><span class="o">*</span> <span class="n">kr_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture</span><span class="o">*</span> <span class="n">kt_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture</span><span class="o">*</span> <span class="n">rs_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture</span><span class="o">*</span> <span class="n">bump_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture</span><span class="o">*</span> <span class="n">disp_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture</span><span class="o">*</span> <span class="n">norm_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture</span><span class="o">*</span> <span class="n">occ_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture_info</span><span class="o">*</span> <span class="n">ke_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture_info</span><span class="o">*</span> <span class="n">kd_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture_info</span><span class="o">*</span> <span class="n">ks_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture_info</span><span class="o">*</span> <span class="n">kr_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture_info</span><span class="o">*</span> <span class="n">kt_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture_info</span><span class="o">*</span> <span class="n">rs_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture_info</span><span class="o">*</span> <span class="n">bump_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture_info</span><span class="o">*</span> <span class="n">disp_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture_info</span><span class="o">*</span> <span class="n">norm_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture_info</span><span class="o">*</span> <span class="n">occ_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="o">~</span><span class="n">material</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Material for surfaces, lines and triangles.</p>
<ul>
<li>Members:<ul>
<li>name:      Name.</li>
<li>double_sided:      Double-sided rendering.</li>
<li>type:      Material type.</li>
<li>ke:      Emission color.  refl_uilimits(0,10000)</li>
<li>kd:      Diffuse color / base color. </li>
<li>ks:      Specular color / metallic factor. </li>
<li>kr:      Clear coat reflection. </li>
<li>kt:      Transmission color. </li>
<li>rs:      Roughness.</li>
<li>op:      Opacity.</li>
<li>ke_txt:      Emission texture. </li>
<li>kd_txt:      Diffuse texture. </li>
<li>ks_txt:      Specular texture. </li>
<li>kr_txt:      Clear coat reflection texture. </li>
<li>kt_txt:      Transmission texture. </li>
<li>rs_txt:      Roughness texture. </li>
<li>bump_txt:      Bump map texture (heighfield). </li>
<li>disp_txt:      Displacement map texture (heighfield). </li>
<li>norm_txt:      Normal texture. </li>
<li>occ_txt:      Occlusion texture. </li>
<li>ke_txt_info:      Emission texture info.</li>
<li>kd_txt_info:      Diffuse texture info.</li>
<li>ks_txt_info:      Specular texture info.</li>
<li>kr_txt_info:      Clear coat reflection texture info.</li>
<li>kt_txt_info:      Transmission texture info.</li>
<li>rs_txt_info:      Roughness texture info.</li>
<li>bump_txt_info:      Bump map texture (heighfield) info.</li>
<li>disp_txt_info:      Displacement map texture (heighfield) info.</li>
<li>norm_txt_info:      Normal texture info.</li>
<li>occ_txt_info:      Occlusion texture info.</li>
<li>~material():      Cleanup.</li>
</ul>
</li>
</ul>
<h4>Struct shape</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">shape</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">material</span><span class="o">*</span> <span class="n">mat</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;</span> <span class="n">lines</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span> <span class="n">triangles</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span> <span class="n">quads</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span> <span class="n">quads_pos</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span> <span class="n">quads_norm</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span> <span class="n">quads_texcoord</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span> <span class="n">beziers</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">pos</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">norm</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span> <span class="n">texcoord</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span> <span class="n">texcoord1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;</span> <span class="n">color</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">radius</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;</span> <span class="n">tangsp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">subdivision</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">catmullclark</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Shape data represented as an indexed array. May contain only one of the
points/lines/triangles/quads.</p>
<ul>
<li>Members:<ul>
<li>name:      Name.</li>
<li>mat:      Material. </li>
<li>points:      Points.</li>
<li>lines:      Lines.</li>
<li>triangles:      Triangles.</li>
<li>quads:      Quads.</li>
<li>quads_pos:      Face-varying indices for position.</li>
<li>quads_norm:      Face-varying indices for normal.</li>
<li>quads_texcoord:      Face-varying indices for texcoord.</li>
<li>beziers:      Bezier.</li>
<li>pos:      Vertex position.</li>
<li>norm:      Vertex normals.</li>
<li>texcoord:      Vertex texcoord.</li>
<li>texcoord1:      Vertex second texcoord.</li>
<li>color:      Vertex color.</li>
<li>radius:      per-vertex radius.</li>
<li>tangsp:      Vertex tangent space.</li>
<li>subdivision:      Number of times to subdivide.</li>
<li>catmullclark:      Whether to use Catmull-Clark subdivision.</li>
</ul>
</li>
</ul>
<h4>Struct shape_group</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">shape_group</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">shape</span><span class="o">*&gt;</span> <span class="n">shapes</span><span class="p">;</span>
    <span class="o">~</span><span class="n">shape_group</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Group of shapes.</p>
<ul>
<li>Members:<ul>
<li>name:      Name.</li>
<li>path:      Path used for saving in glTF.</li>
<li>shapes:      Shapes.</li>
<li>~shape_group():      Cleanup.</li>
</ul>
</li>
</ul>
<h4>Struct instance</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">instance</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">frame3f</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">identity_frame3f</span><span class="p">;</span>
    <span class="n">shape_group</span><span class="o">*</span> <span class="n">shp</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Shape instance.</p>
<ul>
<li>Members:<ul>
<li>name:      Name.</li>
<li>frame:      Transform frame.</li>
<li>shp:      Shape instance. </li>
</ul>
</li>
</ul>
<h4>Struct environment</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">environment</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">frame3f</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">identity_frame3f</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">ke</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">texture</span><span class="o">*</span> <span class="n">ke_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture_info</span><span class="o">*</span> <span class="n">ke_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Envinonment map.</p>
<ul>
<li>Members:<ul>
<li>name:      Name.</li>
<li>frame:      Transform frame.</li>
<li>ke:      Emission coefficient. </li>
<li>ke_txt:      Emission texture. </li>
<li>ke_txt_info:      Emission texture info.</li>
</ul>
</li>
</ul>
<h4>Struct node</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">node</span><span class="o">*</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">frame3f</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">identity_frame3f</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">translation</span> <span class="o">=</span> <span class="n">zero3f</span><span class="p">;</span>
    <span class="n">quat4f</span> <span class="n">rotation</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">scaling</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">weights</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">camera</span><span class="o">*</span> <span class="n">cam</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">instance</span><span class="o">*</span> <span class="n">ist</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">environment</span><span class="o">*</span> <span class="n">env</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">*&gt;</span> <span class="n">children_</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>Node in a transform hierarchy.</p>
<ul>
<li>Members:<ul>
<li>name:      Name.</li>
<li>parent:      Parent node. </li>
<li>frame:      Transform frame.</li>
<li>translation:      Translation.</li>
<li>rotation:      Rotation.</li>
<li>scaling:      Scaling. </li>
<li>weights:      Weights for morphing.</li>
<li>cam:      Camera the node points to. </li>
<li>ist:      Instance the node points to. </li>
<li>env:      Environment the node points to. </li>
<li>children_:      Child nodes. This is a computed value only stored for convenience.</li>
</ul>
</li>
</ul>
<h4>Enum keyframe_type</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">keyframe_type</span> <span class="p">{</span>
    <span class="n">linear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">catmull_rom</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">bezier</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Keyframe type.</p>
<ul>
<li>Values:<ul>
<li>linear:      Linear interpolation.</li>
<li>step:      Step function.</li>
<li>catmull_rom:      Catmull-Rom interpolation.</li>
<li>bezier:      Cubic Bezier interpolation.</li>
</ul>
</li>
</ul>
<h4>Struct animation</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">animation</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">keyframe_type</span> <span class="n">type</span> <span class="o">=</span> <span class="n">keyframe_type</span><span class="o">::</span><span class="n">linear</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">times</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">translation</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">quat4f</span><span class="o">&gt;</span> <span class="n">rotation</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">scaling</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&gt;</span> <span class="n">weights</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Keyframe data.</p>
<ul>
<li>Members:<ul>
<li>name:      Name.</li>
<li>type:      Interpolation.</li>
<li>times:      Times.</li>
<li>translation:      Translation.</li>
<li>rotation:      Rotation.</li>
<li>scaling:      Scaling. </li>
<li>weights:      Weights for morphing.</li>
</ul>
</li>
</ul>
<h4>Struct animation_group</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">animation_group</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">animation</span><span class="o">*&gt;</span> <span class="n">animations</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">animation</span><span class="o">*</span><span class="p">,</span> <span class="n">node</span><span class="o">*&gt;&gt;</span> <span class="n">targets</span><span class="p">;</span>
    <span class="o">~</span><span class="n">animation_group</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Animation made of multiple keyframed values.</p>
<ul>
<li>Members:<ul>
<li>name:      Name.</li>
<li>path:      Path  used when writing files on disk with glTF.</li>
<li>animations:      Keyframed values.</li>
<li>targets:      Binds keyframe values to nodes. </li>
<li>~animation_group():      Cleanup.</li>
</ul>
</li>
</ul>
<h4>Struct scene</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">scene</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">shape_group</span><span class="o">*&gt;</span> <span class="n">shapes</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">instance</span><span class="o">*&gt;</span> <span class="n">instances</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">material</span><span class="o">*&gt;</span> <span class="n">materials</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">texture</span><span class="o">*&gt;</span> <span class="n">textures</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">camera</span><span class="o">*&gt;</span> <span class="n">cameras</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">environment</span><span class="o">*&gt;</span> <span class="n">environments</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">*&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">animation_group</span><span class="o">*&gt;</span> <span class="n">animations</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="o">~</span><span class="n">scene</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Scene comprised an array of objects whose memory is owened by the scene.
All members are optional, but different algorithm might require different
data to be laoded. Scene objects (camera, instances, environments) have
transforms defined internally. A scene can optionally contain a
node hierarchy where each node might point to a camera, instance or
environment. In that case, the element transforms are computed from
the hierarchy. Animation is also optional, with keyframe data that
updates node transformations only if defined.</p>
<ul>
<li>Members:<ul>
<li>shapes:      Shapes.</li>
<li>instances:      Shape instances.</li>
<li>materials:      Materials.</li>
<li>textures:      Textures.</li>
<li>cameras:      Cameras.</li>
<li>environments:      Environments.</li>
<li>nodes:      Node hierarchy.</li>
<li>animations:      Node animations.</li>
<li>~scene():      Cleanup.</li>
</ul>
</li>
</ul>
<h4>Function eval_pos()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec3f</span> <span class="nf">eval_pos</span><span class="p">(</span><span class="k">const</span> <span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eid</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Shape position interpolated using barycentric coordinates.</p>
<h4>Function eval_norm()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec3f</span> <span class="nf">eval_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eid</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Shape normal interpolated using barycentric coordinates.</p>
<h4>Function eval_texcoord()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec2f</span> <span class="nf">eval_texcoord</span><span class="p">(</span><span class="k">const</span> <span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eid</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Shape texcoord interpolated using barycentric coordinates.</p>
<h4>Function eval_color()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec4f</span> <span class="nf">eval_color</span><span class="p">(</span><span class="k">const</span> <span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eid</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Shape color interpolated using barycentric coordinates.</p>
<h4>Function eval_radius()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">float</span> <span class="nf">eval_radius</span><span class="p">(</span><span class="k">const</span> <span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eid</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Shape radius interpolated using barycentric coordinates.</p>
<h4>Function eval_tangsp()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec4f</span> <span class="nf">eval_tangsp</span><span class="p">(</span><span class="k">const</span> <span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eid</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Shape tangent space interpolated using barycentric coordinates.</p>
<h4>Function eval_pos()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec3f</span> <span class="nf">eval_pos</span><span class="p">(</span><span class="k">const</span> <span class="n">instance</span><span class="o">*</span> <span class="n">ist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eid</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Instance position interpolated using barycentric coordinates.</p>
<h4>Function eval_norm()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec3f</span> <span class="nf">eval_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">instance</span><span class="o">*</span> <span class="n">ist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eid</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Instance normal interpolated using barycentric coordinates.</p>
<h4>Function eval_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec4f</span> <span class="n">eval_texture</span><span class="p">(</span><span class="k">const</span> <span class="n">texture</span><span class="o">*</span> <span class="n">txt</span><span class="p">,</span> <span class="k">const</span> <span class="n">texture_info</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">texcoord</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">srgb</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">def</span> <span class="o">=</span><span class="p">;</span>
</code></pre></div>


<p>Evaluate a texture.</p>
<h4>Function eval_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="n">eval_texture</span><span class="p">(</span><span class="k">const</span> <span class="n">texture</span><span class="o">*</span> <span class="n">txt</span><span class="p">,</span> <span class="k">const</span> <span class="n">texture_info</span><span class="o">*</span> <span class="n">info</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">texcoord</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">srgb</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">def</span> <span class="o">=</span><span class="p">;</span>
</code></pre></div>


<p>Evaluate a texture.</p>
<h4>Function eval_camera_ray()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">ray3f</span> <span class="nf">eval_camera_ray</span><span class="p">(</span><span class="k">const</span> <span class="n">camera</span><span class="o">*</span> <span class="n">cam</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">uv</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">luv</span><span class="p">);</span>
</code></pre></div>


<p>Generates a ray from a camera for image plane coordinate <code>uv</code> and the
lens coordinates <code>luv</code>.</p>
<h4>Function eval_camera_ray()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">ray3f</span> <span class="nf">eval_camera_ray</span><span class="p">(</span><span class="k">const</span> <span class="n">camera</span><span class="o">*</span> <span class="n">cam</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">ij</span><span class="p">,</span> <span class="kt">int</span> <span class="n">res</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">puv</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">luv</span><span class="p">);</span>
</code></pre></div>


<p>Generates a ray from a camera for pixel coordinates <code>ij</code>, the resolution
<code>res</code>, the sub-pixel coordinates <code>puv</code> and the lens coordinates <code>luv</code> and
the image resolution <code>res</code>.</p>
<h4>Function sync_camera_aspect()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">sync_camera_aspect</span><span class="p">(</span><span class="n">camera</span><span class="o">*</span> <span class="n">cam</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">height</span><span class="p">);</span>
</code></pre></div>


<p>Synchronizes a camera aspect with image width and height. Set image
values any one is 0 or less. Set camera aspect otherwise.</p>
<h4>Function find_named_elem()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span><span class="o">*</span> <span class="n">find_named_elem</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;&amp;</span> <span class="n">elems</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">);</span>
</code></pre></div>


<p>Finds an element by name.</p>
<h4>Function compute_normals()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">compute_normals</span><span class="p">(</span><span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">);</span>
</code></pre></div>


<p>Update the normals of a shape.  Supports only non-facevarying shapes.</p>
<h4>Function subdivide_shape_once()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">subdivide_shape_once</span><span class="p">(</span><span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">subdiv</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Subdivides shape elements. Apply subdivision surface rules if subdivide
is true.</p>
<h4>Function facet_shape()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">facet_shape</span><span class="p">(</span><span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">recompute_normals</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Facet a shape elements by duplicating vertices. Supports only
non-facevarying shapes.</p>
<h4>Function tesselate_shape()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">tesselate_shape</span><span class="p">(</span><span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">subdivide</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">facevarying_to_sharedvertex</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">quads_to_triangles</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">bezier_to_lines</span><span class="p">);</span>
</code></pre></div>


<p>Tesselate a shape into basic primitives.</p>
<h4>Function tesselate_shapes()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">tesselate_shapes</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">subdivide</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">facevarying_to_sharedvertex</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">quads_to_triangles</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">bezier_to_lines</span><span class="p">);</span>
</code></pre></div>


<p>Tesselate scene shapes.</p>
<h4>Function update_transforms()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">update_transforms</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">float</span> <span class="n">time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div>


<p>Update node transforms.</p>
<h4>Function compute_animation_range()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec2f</span> <span class="nf">compute_animation_range</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Compute animation range.</p>
<h4>Function make_view_camera()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">camera</span><span class="o">*</span> <span class="nf">make_view_camera</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">camera_id</span><span class="p">);</span>
</code></pre></div>


<p>Make a view camera either copying a given one or building a default one.</p>
<h4>Function compute_bounds()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">bbox3f</span> <span class="nf">compute_bounds</span><span class="p">(</span><span class="k">const</span> <span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">);</span>
</code></pre></div>


<p>Computes a shape bounding box using a quick computation that ignores radius.</p>
<h4>Function compute_bounds()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">bbox3f</span> <span class="nf">compute_bounds</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Compute a scene bounding box.</p>
<h4>Function flatten_instances()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">flatten_instances</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Flatten scene instances into separate shapes.</p>
<h4>Function print_info()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">print_info</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Print scene information.</p>
<h4>Function make_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">bvh_tree</span><span class="o">*</span> <span class="nf">make_bvh</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">,</span> <span class="kt">float</span> <span class="n">def_radius</span> <span class="o">=</span> <span class="mf">0.001f</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">equalsize</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Build a shape BVH.</p>
<h4>Function make_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">bvh_tree</span><span class="o">*</span> <span class="nf">make_bvh</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">float</span> <span class="n">def_radius</span> <span class="o">=</span> <span class="mf">0.001f</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">equalsize</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Build a scene BVH.</p>
<h4>Function refit_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">refit_bvh</span><span class="p">(</span><span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">,</span> <span class="kt">float</span> <span class="n">def_radius</span> <span class="o">=</span> <span class="mf">0.001f</span><span class="p">);</span>
</code></pre></div>


<p>Refits a scene BVH.</p>
<h4>Function refit_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">refit_bvh</span><span class="p">(</span>
    <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">do_shapes</span><span class="p">,</span> <span class="kt">float</span> <span class="n">def_radius</span> <span class="o">=</span> <span class="mf">0.001f</span><span class="p">);</span>
</code></pre></div>


<p>Refits a scene BVH.</p>
<h4>Struct add_elements_options</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">add_elements_options</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">smooth_normals</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">tangent_space</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">texture_data</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">shape_instances</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">default_names</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">default_paths</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">add_elements_options</span> <span class="nf">none</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Add elements options.</p>
<ul>
<li>Members:<ul>
<li>smooth_normals:      Add missing normal.</li>
<li>tangent_space:      Add missing trangent space.</li>
<li>texture_data:      Add empty texture data.</li>
<li>shape_instances:      Add instances.</li>
<li>default_names:      Add default names.</li>
<li>default_paths:      Add default paths.</li>
<li>none():      Initialize to no elements.</li>
</ul>
</li>
</ul>
<h4>Function add_elements()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="n">add_elements</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">add_elements_options</span><span class="o">&amp;</span> <span class="n">opts</span> <span class="o">=</span><span class="p">;</span>
</code></pre></div>


<p>Add elements</p>
<h4>Function merge_into()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">merge_into</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">merge_into</span><span class="p">,</span> <span class="n">scene</span><span class="o">*</span> <span class="n">merge_from</span><span class="p">);</span>
</code></pre></div>


<p>Merge scene into one another. Note that the objects are <em>moved</em> from
merge_from to merged_into, so merge_from will be empty after this function.</p>
<h4>Struct load_options</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">load_options</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">load_textures</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">skip_missing</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">obj_flip_texcoord</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">obj_facet_non_smooth</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">obj_flip_tr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">preserve_quads</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">preserve_facevarying</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">preserve_hierarchy</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Loading options.</p>
<ul>
<li>Members:<ul>
<li>load_textures:      Whether to load textures.</li>
<li>skip_missing:      Skip missing files without giving and error.</li>
<li>obj_flip_texcoord:      Whether to flip the v coordinate in OBJ.</li>
<li>obj_facet_non_smooth:      Duplicate vertices if smoothing off in OBJ.</li>
<li>obj_flip_tr:      Whether to flip tr in OBJ.</li>
<li>preserve_quads:      Whether to preserve quads.</li>
<li>preserve_facevarying:      Whether to preserve face-varying faces.</li>
<li>preserve_hierarchy:      Whether to preserve node hierarchy.</li>
</ul>
</li>
</ul>
<h4>Function load_scene()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">scene</span><span class="o">*</span> <span class="n">load_scene</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">load_options</span><span class="o">&amp;</span> <span class="n">opts</span> <span class="o">=</span><span class="p">;</span>
</code></pre></div>


<p>Loads a scene. For now OBJ or glTF are supported.
Throws an exception if an error occurs.</p>
<h4>Struct save_options</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">save_options</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">save_textures</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">skip_missing</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">obj_flip_texcoord</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">obj_flip_tr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">gltf_separate_buffers</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Save options.</p>
<ul>
<li>Members:<ul>
<li>save_textures:      Whether to save textures.</li>
<li>skip_missing:      Skip missing files without giving and error.</li>
<li>obj_flip_texcoord:      Whether to flip the v coordinate in OBJ.</li>
<li>obj_flip_tr:      Whether to flip tr in OBJ.</li>
<li>gltf_separate_buffers:      Whether to use separate buffers in gltf.</li>
</ul>
</li>
</ul>
<h4>Function save_scene()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">save_scene</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">save_options</span><span class="o">&amp;</span> <span class="n">opts</span><span class="p">);</span>
</code></pre></div>


<p>Saves a scene. For now OBJ and glTF are supported.</p>
<h4>Function enum_names&lt;material_type>()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">material_type</span><span class="o">&gt;&gt;&amp;</span>
<span class="n">enum_names</span><span class="o">&lt;</span><span class="n">material_type</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div>


<p>Names of enum values.</p>
<h4>Function enum_names&lt;keyframe_type>()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">keyframe_type</span><span class="o">&gt;&gt;&amp;</span>
<span class="n">enum_names</span><span class="o">&lt;</span><span class="n">keyframe_type</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div>


<p>Names of enum values.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">camera</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">texture</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">texture_info</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">material</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">shape</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">shape_group</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">instance</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">environment</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">animation</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">animation_group</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">scene</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<p><a id="toc50"></a></p>
<h3>Example scenes</h3>
<h4>Struct proc_camera</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">proc_camera</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">from</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">to</span> <span class="o">=</span> <span class="n">zero3f</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">yfov</span> <span class="o">=</span> <span class="mi">45</span> <span class="o">*</span> <span class="n">pif</span> <span class="o">/</span> <span class="mi">180</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">aspect</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Procedural camera parameters.</p>
<ul>
<li>Members:<ul>
<li>name:      Name.</li>
<li>from:      From point. </li>
<li>to:      To point. </li>
<li>yfov:      Field of view. </li>
<li>aspect:      Aspect ratio. </li>
</ul>
</li>
</ul>
<h4>Enum proc_texture_type</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">proc_texture_type</span> <span class="p">{</span>
    <span class="n">none</span><span class="p">,</span>
    <span class="n">grid</span><span class="p">,</span>
    <span class="n">checker</span><span class="p">,</span>
    <span class="n">colored</span><span class="p">,</span>
    <span class="n">rcolored</span><span class="p">,</span>
    <span class="n">bump</span><span class="p">,</span>
    <span class="n">uv</span><span class="p">,</span>
    <span class="n">gamma</span><span class="p">,</span>
    <span class="n">noise</span><span class="p">,</span>
    <span class="n">ridge</span><span class="p">,</span>
    <span class="n">fbm</span><span class="p">,</span>
    <span class="n">turbulence</span><span class="p">,</span>
    <span class="n">gammaf</span><span class="p">,</span>
    <span class="n">sky</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Procedural texture type.</p>
<ul>
<li>Values:<ul>
<li>none:      None (empty texture).</li>
<li>grid:      Grid image.</li>
<li>checker:      Checker image.</li>
<li>colored:      Colored checker image.</li>
<li>rcolored:      Detailed colored checker image.</li>
<li>bump:      Bump and dimple imahe.</li>
<li>uv:      Uv debug image.</li>
<li>gamma:      Gamma ramp.</li>
<li>noise:      Perlin noise image.</li>
<li>ridge:      Perlin ridge image.</li>
<li>fbm:      Perlin fbm image.</li>
<li>turbulence:      Perlin turbulence image.</li>
<li>gammaf:      Gamma ramp (HDR).</li>
<li>sky:      Sky (HDR).</li>
</ul>
</li>
</ul>
<h4>Struct proc_texture</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">proc_texture</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">proc_texture_type</span> <span class="n">type</span> <span class="o">=</span> <span class="n">proc_texture_type</span><span class="o">::</span><span class="n">none</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">resolution</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">tile_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">noise_scale</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">sky_sunangle</span> <span class="o">=</span> <span class="n">pif</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">bump_to_normal</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">bump_scale</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Procedural texture parameters.</p>
<ul>
<li>Members:<ul>
<li>name:      Name.</li>
<li>type:      Type.</li>
<li>resolution:      Resolution. </li>
<li>tile_size:      Tile size for grid-like textures. </li>
<li>noise_scale:      Noise scale for noise-like textures. </li>
<li>sky_sunangle:      Sun angle for sunsky-like textures. </li>
<li>bump_to_normal:      Convert to normal map.</li>
<li>bump_scale:      Bump to normal scale. </li>
</ul>
</li>
</ul>
<h4>Enum proc_material_type</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">proc_material_type</span> <span class="p">{</span>
    <span class="n">none</span><span class="p">,</span>
    <span class="n">emission</span><span class="p">,</span>
    <span class="n">matte</span><span class="p">,</span>
    <span class="n">plastic</span><span class="p">,</span>
    <span class="n">metal</span><span class="p">,</span>
    <span class="n">transparent</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Procedural material type.</p>
<ul>
<li>Values:<ul>
<li>none:      None (empty material).</li>
<li>emission:      Emission.</li>
<li>matte:      Matte (diffuse).</li>
<li>plastic:      Plastic.</li>
<li>metal:      Matetal.</li>
<li>transparent:      Transparent (diffuse with opacity).</li>
</ul>
</li>
</ul>
<h4>Struct proc_material</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">proc_material</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">proc_material_type</span> <span class="n">type</span> <span class="o">=</span> <span class="n">proc_material_type</span><span class="o">::</span><span class="n">matte</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">emission</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">color</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">};</span>
    <span class="kt">float</span> <span class="n">opacity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">roughness</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">texture</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">normal</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Procedural material parameters.</p>
<ul>
<li>Members:<ul>
<li>name:      Name.</li>
<li>type:      Type.</li>
<li>emission:      Emission strenght. </li>
<li>color:      Base color. </li>
<li>opacity:      Opacity (only for supported materials).</li>
<li>roughness:      Roughness.</li>
<li>texture:      Base texture.</li>
<li>normal:      Normal map.</li>
</ul>
</li>
</ul>
<h4>Enum proc_shape_type</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">proc_shape_type</span> <span class="p">{</span>
    <span class="n">floor</span><span class="p">,</span>
    <span class="n">quad</span><span class="p">,</span>
    <span class="n">cube</span><span class="p">,</span>
    <span class="n">sphere</span><span class="p">,</span>
    <span class="n">spherecube</span><span class="p">,</span>
    <span class="n">spherizedcube</span><span class="p">,</span>
    <span class="n">geosphere</span><span class="p">,</span>
    <span class="n">flipcapsphere</span><span class="p">,</span>
    <span class="n">suzanne</span><span class="p">,</span>
    <span class="n">cubep</span><span class="p">,</span>
    <span class="n">fvcube</span><span class="p">,</span>
    <span class="n">fvsphere</span><span class="p">,</span>
    <span class="n">matball</span><span class="p">,</span>
    <span class="n">point</span><span class="p">,</span>
    <span class="n">pointscube</span><span class="p">,</span>
    <span class="n">hairball</span><span class="p">,</span>
    <span class="n">beziercircle</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Procedural shape type.</p>
<ul>
<li>Values:<ul>
<li>floor:      Floor (shared vertex, 20x20 size).</li>
<li>quad:      Quad (shared vertex).</li>
<li>cube:      Cube (shared vertex, not watertight).</li>
<li>sphere:      Sphere (shared vertex, not watertight).</li>
<li>spherecube:      Sphere with cube uvs (shared vertex, not watertight).</li>
<li>spherizedcube:      Spherized cube (shared vertex, not watertight).</li>
<li>geosphere:      Geodesic sphere (shared vertex, watertight, no texcoord).</li>
<li>flipcapsphere:      Sphere with flipped cap (shared vertex, not watertight).</li>
<li>suzanne:      Suzanne (shared vertex, no texcoord).</li>
<li>cubep:      Position-only cube (shared vertex).</li>
<li>fvcube:      Face-varying cube (shared vertex).</li>
<li>fvsphere:      Face-varying sphere (shared vertex).</li>
<li>matball:      Matball (shared vertex, not watertight).</li>
<li>point:      Single point.</li>
<li>pointscube:      Random points in a cube.</li>
<li>hairball:      Random lines on a sphere.</li>
<li>beziercircle:      Bezier circle.</li>
</ul>
</li>
</ul>
<h4>Struct proc_shape</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">proc_shape</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">proc_shape_type</span> <span class="n">type</span> <span class="o">=</span> <span class="n">proc_shape_type</span><span class="o">::</span><span class="n">sphere</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">material</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">interior</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">tesselation</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">subdivision</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">radius</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">faceted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">make_hair_params</span><span class="o">*</span> <span class="n">hair_params</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="o">~</span><span class="n">proc_shape</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Procedural shape parameters.</p>
<ul>
<li>
<p>Members:</p>
<ul>
<li>name:      Shape name (if not filled, assign a default based on type).</li>
<li>type:      Shape type.</li>
<li>material:      Material name.</li>
<li>interior:      Interior material name.</li>
<li>tesselation:      Level of shape tesselatation (-1 for default). </li>
<li>
<p>subdivision:      Level of shape tesselation for subdivision surfaces.</p>
</li>
<li>
<p>scale:      Shape scale. </p>
</li>
<li>radius:      Radius for points and lines. </li>
<li>faceted:      Faceted shape.</li>
<li>
<p>num:      Number of elements for points and lines (-1 for default).</p>
</li>
<li>
<p>hair_params:      Hair generation params.</p>
</li>
<li>~proc_shape():      Cleanup</li>
</ul>
</li>
</ul>
<h4>Struct proc_instance</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">proc_instance</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">shape</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">frame3f</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">identity_frame3f</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">rotation</span> <span class="o">=</span> <span class="n">zero3f</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Procedural instance parameters.</p>
<ul>
<li>Members:<ul>
<li>name:      Name (if not filled, assign a default one).</li>
<li>shape:      Shape name.</li>
<li>frame:      Base frame.</li>
<li>rotation:      Rotation in Euler angles.</li>
</ul>
</li>
</ul>
<h4>Struct proc_environment</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">proc_environment</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">emission</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">color</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">texture</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">frame3f</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">identity_frame3f</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">rotation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Procedural environment parameters.</p>
<ul>
<li>Members:<ul>
<li>name:      Name.</li>
<li>emission:      Emission strenght. </li>
<li>color:      Emission color. </li>
<li>texture:      Emission texture.</li>
<li>frame:      Frame.</li>
<li>rotation:      Rotation around y axis. </li>
</ul>
</li>
</ul>
<h4>Struct proc_node</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">proc_node</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">parent</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">camera</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">instance</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">environment</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">frame3f</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">identity_frame3f</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">translation</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">quat4f</span> <span class="n">rotation</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">scaling</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div>


<p>Procedural node parameters.</p>
<ul>
<li>Members:<ul>
<li>name:      Name.</li>
<li>parent:      Parent node.</li>
<li>camera:      Camera.</li>
<li>instance:      Instance.</li>
<li>environment:      Environment.</li>
<li>frame:      Frame.</li>
<li>translation:      Translation. </li>
<li>rotation:      Roation.</li>
<li>scaling:      Scaling. </li>
</ul>
</li>
</ul>
<h4>Struct proc_animation</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">proc_animation</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">bezier</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">speed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">times</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">translation</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">quat4f</span><span class="o">&gt;</span> <span class="n">rotation</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">scaling</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>Procedural animation parameters.</p>
<ul>
<li>Members:<ul>
<li>name:      Name.</li>
<li>bezier:      Linear or bezier.</li>
<li>speed:      Animation speed. </li>
<li>scale:      Animation scale. </li>
<li>times:      Keyframes times.</li>
<li>translation:      Translation keyframes. </li>
<li>rotation:      Rotation keyframes.</li>
<li>scaling:      Scale keyframes. </li>
<li>nodes:      Environment.</li>
</ul>
</li>
</ul>
<h4>Struct proc_scene</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">proc_scene</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">proc_camera</span><span class="o">*&gt;</span> <span class="n">cameras</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">proc_texture</span><span class="o">*&gt;</span> <span class="n">textures</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">proc_material</span><span class="o">*&gt;</span> <span class="n">materials</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">proc_shape</span><span class="o">*&gt;</span> <span class="n">shapes</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">proc_instance</span><span class="o">*&gt;</span> <span class="n">instances</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">proc_environment</span><span class="o">*&gt;</span> <span class="n">environments</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">proc_node</span><span class="o">*&gt;</span> <span class="n">nodes</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">proc_animation</span><span class="o">*&gt;</span> <span class="n">animations</span><span class="p">;</span>
    <span class="o">~</span><span class="n">proc_scene</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Procedural scene.</p>
<ul>
<li>Members:<ul>
<li>name:      Name.</li>
<li>cameras:      Cameras.</li>
<li>textures:      Textures.</li>
<li>materials:      Materials.</li>
<li>shapes:      Shapes.</li>
<li>instances:      Instances.</li>
<li>environments:      Environmennts.</li>
<li>nodes:      Nodes.</li>
<li>animations:      Animations.</li>
<li>~proc_scene():      Cleanup.</li>
</ul>
</li>
</ul>
<h4>Function make_cornell_box_scene()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">scene</span><span class="o">*</span> <span class="nf">make_cornell_box_scene</span><span class="p">();</span>
</code></pre></div>


<p>Makes the Cornell Box scene.</p>
<h4>Function update_proc_elem()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">update_proc_elem</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="n">camera</span><span class="o">*</span> <span class="n">cam</span><span class="p">,</span> <span class="k">const</span> <span class="n">proc_camera</span><span class="o">*</span> <span class="n">tcam</span><span class="p">);</span>
</code></pre></div>


<p>Updates a procesural camera.</p>
<h4>Function update_proc_elem()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">update_proc_elem</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="n">texture</span><span class="o">*</span> <span class="n">txt</span><span class="p">,</span> <span class="k">const</span> <span class="n">proc_texture</span><span class="o">*</span> <span class="n">ttxt</span><span class="p">);</span>
</code></pre></div>


<p>Updates a procedural texture.</p>
<h4>Function update_proc_elem()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">update_proc_elem</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="n">material</span><span class="o">*</span> <span class="n">mat</span><span class="p">,</span> <span class="k">const</span> <span class="n">proc_material</span><span class="o">*</span> <span class="n">tmat</span><span class="p">);</span>
</code></pre></div>


<p>Updates a procedural material.</p>
<h4>Function update_proc_elem()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">update_proc_elem</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">,</span> <span class="k">const</span> <span class="n">proc_shape</span><span class="o">*</span> <span class="n">tshp</span><span class="p">);</span>
</code></pre></div>


<p>Updates a procedural shape, adding it to the scene if missing.</p>
<h4>Function update_proc_elem()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">update_proc_elem</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="n">instance</span><span class="o">*</span> <span class="n">ist</span><span class="p">,</span> <span class="k">const</span> <span class="n">proc_instance</span><span class="o">*</span> <span class="n">tist</span><span class="p">);</span>
</code></pre></div>


<p>Updates a procedural instance.</p>
<h4>Function update_proc_elem()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">update_proc_elem</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="n">environment</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="k">const</span> <span class="n">proc_environment</span><span class="o">*</span> <span class="n">tenv</span><span class="p">);</span>
</code></pre></div>


<p>Updates a procedural instance.</p>
<h4>Function update_proc_elem()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">update_proc_elem</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="n">node</span><span class="o">*</span> <span class="n">nde</span><span class="p">,</span> <span class="k">const</span> <span class="n">proc_node</span><span class="o">*</span> <span class="n">tndr</span><span class="p">);</span>
</code></pre></div>


<p>Updates a procedural node.</p>
<h4>Function update_proc_elem()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">update_proc_elem</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="n">animation_group</span><span class="o">*</span> <span class="n">anm</span><span class="p">,</span> <span class="k">const</span> <span class="n">proc_animation</span><span class="o">*</span> <span class="n">tndr</span><span class="p">);</span>
</code></pre></div>


<p>Updates a procedural animation.</p>
<h4>Function update_proc_elems()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="n">update_proc_elems</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">proc_scene</span><span class="o">*</span> <span class="n">tscn</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;&amp;</span> <span class="n">refresh</span> <span class="o">=</span><span class="p">;</span>
</code></pre></div>


<p>Updates a procedural scene, adding missing objects. Objects are only added
and never removed.</p>
<h4>Function make_proc_elems()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">scene</span><span class="o">*</span> <span class="nf">make_proc_elems</span><span class="p">(</span><span class="k">const</span> <span class="n">proc_scene</span><span class="o">*</span> <span class="n">tscn</span><span class="p">);</span>
</code></pre></div>


<p>Makes a test scene. Convenience wrapper around <code>update_test_scene()</code>.</p>
<h4>Function proc_camera_presets()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">proc_camera</span><span class="o">*&gt;&amp;</span> <span class="n">proc_camera_presets</span><span class="p">();</span>
</code></pre></div>


<p>Procedural camera presets.</p>
<h4>Function proc_texture_presets()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">proc_texture</span><span class="o">*&gt;&amp;</span> <span class="n">proc_texture_presets</span><span class="p">();</span>
</code></pre></div>


<p>Procedural texture presets.</p>
<h4>Function proc_material_presets()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">proc_material</span><span class="o">*&gt;&amp;</span> <span class="n">proc_material_presets</span><span class="p">();</span>
</code></pre></div>


<p>Procedural material presets.</p>
<h4>Function proc_shape_presets()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">proc_shape</span><span class="o">*&gt;&amp;</span> <span class="n">proc_shape_presets</span><span class="p">();</span>
</code></pre></div>


<p>Procedural shape presets.</p>
<h4>Function proc_instance_presets()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">proc_instance</span><span class="o">*&gt;&amp;</span> <span class="n">proc_instance_presets</span><span class="p">();</span>
</code></pre></div>


<p>Procedural instance presets.</p>
<h4>Function proc_environment_presets()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">proc_environment</span><span class="o">*&gt;&amp;</span> <span class="n">proc_environment_presets</span><span class="p">();</span>
</code></pre></div>


<p>Procedural environment presets.</p>
<h4>Function proc_node_presets()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">proc_node</span><span class="o">*&gt;&amp;</span> <span class="n">proc_node_presets</span><span class="p">();</span>
</code></pre></div>


<p>Procedural nodes presets.</p>
<h4>Function proc_animation_presets()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">proc_animation</span><span class="o">*&gt;&amp;</span> <span class="n">proc_animation_presets</span><span class="p">();</span>
</code></pre></div>


<p>Procedural animation presets.</p>
<h4>Function proc_scene_presets()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">proc_scene</span><span class="o">*&gt;&amp;</span> <span class="n">proc_scene_presets</span><span class="p">();</span>
</code></pre></div>


<p>Test scene presets.</p>
<h4>Function remove_duplicates()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">remove_duplicates</span><span class="p">(</span><span class="n">proc_scene</span><span class="o">*</span> <span class="n">tscn</span><span class="p">);</span>
</code></pre></div>


<p>Remove duplicates based on name.</p>
<h4>Function load_proc_scene()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">proc_scene</span><span class="o">*</span> <span class="nf">load_proc_scene</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>
</code></pre></div>


<p>Load test scene.</p>
<h4>Function save_proc_scene()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">save_proc_scene</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">proc_scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Save test scene.</p>
<h4>Function enum_names&lt;proc_texture_type>()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">proc_texture_type</span><span class="o">&gt;&gt;&amp;</span>
<span class="n">enum_names</span><span class="o">&lt;</span><span class="n">proc_texture_type</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div>


<p>Names of enum values.</p>
<h4>Function enum_names&lt;proc_material_type>()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">proc_material_type</span><span class="o">&gt;&gt;&amp;</span>
<span class="n">enum_names</span><span class="o">&lt;</span><span class="n">proc_material_type</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div>


<p>Names of enum values.</p>
<h4>Function enum_names&lt;proc_shape_type>()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">proc_shape_type</span><span class="o">&gt;&gt;&amp;</span>
<span class="n">enum_names</span><span class="o">&lt;</span><span class="n">proc_shape_type</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div>


<p>Names of enum values.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">proc_camera</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">proc_texture</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">proc_material</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">proc_shape</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">proc_instance</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">proc_environment</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">proc_node</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">proc_animation</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">proc_scene</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<p><a id="toc51"></a></p>
<h3>Path-tracing support</h3>
<h4>Function specular_exponent_to_roughness()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">float</span> <span class="nf">specular_exponent_to_roughness</span><span class="p">(</span><span class="kt">float</span> <span class="n">n</span><span class="p">);</span>
</code></pre></div>


<p>Phong exponent to roughness.</p>
<h4>Function specular_fresnel_from_ks()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">specular_fresnel_from_ks</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ks</span><span class="p">,</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">es</span><span class="p">,</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">esk</span><span class="p">);</span>
</code></pre></div>


<p>Specular to fresnel eta.</p>
<h4>Function fresnel_dielectric()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec3f</span> <span class="nf">fresnel_dielectric</span><span class="p">(</span><span class="kt">float</span> <span class="n">cosw</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">eta_</span><span class="p">);</span>
</code></pre></div>


<p>Compute the fresnel term for dielectrics. Implementation from
https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/</p>
<h4>Function fresnel_metal()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec3f</span> <span class="nf">fresnel_metal</span><span class="p">(</span><span class="kt">float</span> <span class="n">cosw</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">eta</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">etak</span><span class="p">);</span>
</code></pre></div>


<p>Compute the fresnel term for metals. Implementation from
https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/</p>
<h4>Function fresnel_schlick()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec3f</span> <span class="nf">fresnel_schlick</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ks</span><span class="p">,</span> <span class="kt">float</span> <span class="n">cosw</span><span class="p">);</span>
</code></pre></div>


<p>Schlick approximation of Fresnel term.</p>
<h4>Function fresnel_schlick()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec3f</span> <span class="nf">fresnel_schlick</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ks</span><span class="p">,</span> <span class="kt">float</span> <span class="n">cosw</span><span class="p">,</span> <span class="kt">float</span> <span class="n">rs</span><span class="p">);</span>
</code></pre></div>


<p>Schlick approximation of Fresnel term weighted by roughness.
This is a hack, but works better than not doing it.</p>
<h4>Function eval_ggx()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">float</span> <span class="nf">eval_ggx</span><span class="p">(</span><span class="kt">float</span> <span class="n">rs</span><span class="p">,</span> <span class="kt">float</span> <span class="n">ndh</span><span class="p">,</span> <span class="kt">float</span> <span class="n">ndi</span><span class="p">,</span> <span class="kt">float</span> <span class="n">ndo</span><span class="p">);</span>
</code></pre></div>


<p>Evaluates the GGX distribution and geometric term.</p>
<h4>Function sample_ggx()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec3f</span> <span class="nf">sample_ggx</span><span class="p">(</span><span class="kt">float</span> <span class="n">rs</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">rn</span><span class="p">);</span>
</code></pre></div>


<p>Sample the GGX distribution.</p>
<h4>Function sample_ggx_pdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">float</span> <span class="nf">sample_ggx_pdf</span><span class="p">(</span><span class="kt">float</span> <span class="n">rs</span><span class="p">,</span> <span class="kt">float</span> <span class="n">ndh</span><span class="p">);</span>
</code></pre></div>


<p>Evaluates the GGX pdf.</p>
<h4>Function filter_triangle()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">filter_triangle</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">);</span>
</code></pre></div>


<p>Triangle filter. Ppublic domain from stb_image_resize.</p>
<h4>Function filter_cubic()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">filter_cubic</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">);</span>
</code></pre></div>


<p>Cubic filter. Ppublic domain from stb_image_resize.</p>
<h4>Function filter_catmullrom()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">filter_catmullrom</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">);</span>
</code></pre></div>


<p>Catmull-rom filter. Ppublic domain from stb_image_resize.</p>
<h4>Function filter_mitchell()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">filter_mitchell</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">);</span>
</code></pre></div>


<p>Mitchell filter. Ppublic domain from stb_image_resize.</p>
<p><a id="toc52"></a></p>
<h3>Path tracing</h3>
<h4>Enum trace_shader_type</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">trace_shader_type</span> <span class="p">{</span>
    <span class="n">pathtrace</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">eyelight</span><span class="p">,</span>
    <span class="n">direct</span><span class="p">,</span>
    <span class="n">pathtrace_nomis</span><span class="p">,</span>
    <span class="n">debug_normal</span><span class="p">,</span>
    <span class="n">debug_albedo</span><span class="p">,</span>
    <span class="n">debug_texcoord</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Type of rendering algorithm.</p>
<ul>
<li>Values:<ul>
<li>pathtrace:      Pathtrace.</li>
<li>eyelight:      Eye light for previews.</li>
<li>direct:      Direct illumination.</li>
<li>pathtrace_nomis:      Pathtrace without MIS.</li>
<li>debug_normal:      Debug normal.</li>
<li>debug_albedo:      Debug albedo.</li>
<li>debug_texcoord:      Debug texcoord.</li>
</ul>
</li>
</ul>
<h4>Enum trace_rng_type</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">trace_rng_type</span> <span class="p">{</span>
    <span class="n">uniform</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">stratified</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Random number generator type.</p>
<ul>
<li>Values:<ul>
<li>uniform:      Uniform random numbers.</li>
<li>stratified:      Stratified random numbers.</li>
</ul>
</li>
</ul>
<h4>Enum trace_filter_type</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">trace_filter_type</span> <span class="p">{</span>
    <span class="n">box</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">triangle</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">cubic</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">catmull_rom</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">mitchell</span> <span class="o">=</span> <span class="mi">5</span>

<span class="p">}</span>
</code></pre></div>


<p>Filter type.</p>
<ul>
<li>Values:<ul>
<li>box:      Box filter.</li>
<li>triangle:      Hat filter.</li>
<li>cubic:      Cubic spline.</li>
<li>catmull_rom:      Catmull-Rom spline.</li>
<li>mitchell:      Mitchell-Netrevalli.</li>
</ul>
</li>
</ul>
<h4>Struct trace_params</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">trace_params</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">resolution</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">nsamples</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
    <span class="n">trace_shader_type</span> <span class="n">shader</span> <span class="o">=</span> <span class="n">trace_shader_type</span><span class="o">::</span><span class="n">pathtrace</span><span class="p">;</span>
    <span class="n">trace_rng_type</span> <span class="n">rng</span> <span class="o">=</span> <span class="n">trace_rng_type</span><span class="o">::</span><span class="n">stratified</span><span class="p">;</span>
    <span class="n">trace_filter_type</span> <span class="n">filter</span> <span class="o">=</span> <span class="n">trace_filter_type</span><span class="o">::</span><span class="n">box</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">notransmission</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">ambient</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="kt">bool</span> <span class="n">envmap_invisible</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">min_depth</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">max_depth</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">pixel_clamp</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">ray_eps</span> <span class="o">=</span> <span class="mf">1e-4</span><span class="n">f</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">parallel</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Rendering params.</p>
<ul>
<li>Members:<ul>
<li>resolution:      Image vertical resolution. </li>
<li>nsamples:      Number of samples.  </li>
<li>shader:      Sampler type. </li>
<li>rng:      Random number generation type. </li>
<li>filter:      Filter type.</li>
<li>notransmission:      Wheter to test transmission in shadows.</li>
<li>ambient:      Ambient lighting. </li>
<li>envmap_invisible:      View environment map.</li>
<li>min_depth:      Minimum ray depth. </li>
<li>max_depth:      Maximum ray depth. </li>
<li>pixel_clamp:      Final pixel clamping. </li>
<li>ray_eps:      Ray intersection epsilon. </li>
<li>parallel:      Parallel execution.</li>
<li>seed:      Seed for the random number generators. </li>
</ul>
</li>
</ul>
<h4>Struct trace_pixel</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">trace_pixel</span> <span class="p">{</span>
    <span class="n">vec3f</span> <span class="n">col</span> <span class="o">=</span> <span class="n">zero3f</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">rng_pcg32</span> <span class="n">rng</span> <span class="o">=</span> <span class="n">rng_pcg32</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">sample</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">dimension</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">weight</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Trace pixel state. Handles image accumulation and random number generation
for uniform and stratified sequences. The members are not part of the
the public API.</p>
<ul>
<li>Members:<ul>
<li>col:      Accumulated radiance.</li>
<li>alpha:      Accumulated coverage.</li>
<li>rng:      Random number state.</li>
<li>i:      Pixel coordinates.</li>
<li>sample:      Number of samples computed.</li>
<li>dimension:      Current dimension.</li>
<li>weight:      Pixel weight for filtering.</li>
</ul>
</li>
</ul>
<h4>Struct trace_light</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">trace_light</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">instance</span><span class="o">*</span> <span class="n">ist</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">environment</span><span class="o">*</span> <span class="n">env</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Trace light as either instances or environments. The members are not part of
the the public API.</p>
<ul>
<li>Members:<ul>
<li>ist:      Instance pointer for instance lights.</li>
<li>env:      Environment pointer for environment lights.</li>
</ul>
</li>
</ul>
<h4>Struct trace_lights</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">trace_lights</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">trace_light</span><span class="o">&gt;</span> <span class="n">lights</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">shape</span><span class="o">*</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&gt;</span> <span class="n">shape_cdfs</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">shape</span><span class="o">*</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span> <span class="n">shape_areas</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div>


<p>Trace lights. Handles sampling of illumination. The members are not part of
the the public API.</p>
<ul>
<li>Members:<ul>
<li>lights:      Shape instances.</li>
<li>shape_cdfs:      Shape cdfs.</li>
<li>shape_areas:      Shape areas.</li>
<li>empty():      Check whether there are any lights.</li>
<li>size():      Number of lights.</li>
</ul>
</li>
</ul>
<h4>Function make_trace_pixels()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image</span><span class="o">&lt;</span><span class="n">trace_pixel</span><span class="o">&gt;</span> <span class="n">make_trace_pixels</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span> <span class="k">const</span> <span class="n">trace_params</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">);</span>
</code></pre></div>


<p>Initialize trace pixels.</p>
<h4>Function make_trace_lights()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">trace_lights</span> <span class="nf">make_trace_lights</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Initialize trace lights.</p>
<h4>Function trace_samples()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">trace_samples</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">camera</span><span class="o">*</span> <span class="n">cam</span><span class="p">,</span> <span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">trace_lights</span><span class="o">&amp;</span> <span class="n">lights</span><span class="p">,</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span> <span class="n">image</span><span class="o">&lt;</span><span class="n">trace_pixel</span><span class="o">&gt;&amp;</span> <span class="n">pixels</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">nsamples</span><span class="p">,</span> <span class="k">const</span> <span class="n">trace_params</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">);</span>
</code></pre></div>


<p>Trace the next <code>nsamples</code> samples.</p>
<h4>Function trace_samples_filtered()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">trace_samples_filtered</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">camera</span><span class="o">*</span> <span class="n">cam</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">trace_lights</span><span class="o">&amp;</span> <span class="n">lights</span><span class="p">,</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span>
    <span class="n">image</span><span class="o">&lt;</span><span class="n">trace_pixel</span><span class="o">&gt;&amp;</span> <span class="n">pixels</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nsamples</span><span class="p">,</span> <span class="k">const</span> <span class="n">trace_params</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">);</span>
</code></pre></div>


<p>Trace the next <code>nsamples</code> samples with image filtering.</p>
<h4>Function trace_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">image4f</span> <span class="nf">trace_image</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">camera</span><span class="o">*</span> <span class="n">cam</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">trace_params</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">);</span>
</code></pre></div>


<p>Trace the whole image.</p>
<h4>Function trace_async_start()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">trace_async_start</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">camera</span><span class="o">*</span> <span class="n">cam</span><span class="p">,</span> <span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">trace_lights</span><span class="o">&amp;</span> <span class="n">lights</span><span class="p">,</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span> <span class="n">image</span><span class="o">&lt;</span><span class="n">trace_pixel</span><span class="o">&gt;&amp;</span> <span class="n">pixels</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;&amp;</span> <span class="n">threads</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&amp;</span> <span class="n">stop_flag</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">trace_params</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">);</span>
</code></pre></div>


<p>Starts an anyncrhounous renderer.</p>
<h4>Function trace_async_stop()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">trace_async_stop</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;&amp;</span> <span class="n">threads</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&amp;</span> <span class="n">stop_flag</span><span class="p">);</span>
</code></pre></div>


<p>Stop the asynchronous renderer.</p>
<h4>Function enum_names&lt;trace_shader_type>()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">trace_shader_type</span><span class="o">&gt;&gt;&amp;</span>
<span class="n">enum_names</span><span class="o">&lt;</span><span class="n">trace_shader_type</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div>


<p>Names of enum values.</p>
<h4>Function enum_names&lt;trace_rng_type>()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">trace_rng_type</span><span class="o">&gt;&gt;&amp;</span>
<span class="n">enum_names</span><span class="o">&lt;</span><span class="n">trace_rng_type</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div>


<p>Names of enum values.</p>
<h4>Function enum_names&lt;trace_filter_type>()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">trace_filter_type</span><span class="o">&gt;&gt;&amp;</span>
<span class="n">enum_names</span><span class="o">&lt;</span><span class="n">trace_filter_type</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div>


<p>Names of enum values.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">trace_params</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<p><a id="toc53"></a></p>
<h3>Wavefront OBJ</h3>
<h4>Struct obj_vertex</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">obj_vertex</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">texcoord</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">norm</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">color</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">radius</span><span class="p">;</span>
    <span class="n">obj_vertex</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">texcoord</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">norm</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">color</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">radius</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> 
<span class="p">}</span>
</code></pre></div>


<p>Obj face vertex.</p>
<ul>
<li>Members:<ul>
<li>pos:      Position.</li>
<li>texcoord:      Texcoord.</li>
<li>norm:      Normal.</li>
<li>color:      Color [extension].</li>
<li>radius:      Radius [extension].</li>
<li>obj_vertex():      Element constructor. Initializes all non-specified members as -1.</li>
</ul>
</li>
</ul>
<h4>Enum obj_element_type : uint16_t</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="nl">obj_element_type</span> <span class="p">:</span> <span class="kt">uint16_t</span> <span class="p">{</span>
    <span class="n">point</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">line</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">face</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">bezier</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Obj element type.</p>
<ul>
<li>Values:<ul>
<li>point:      List of points.</li>
<li>line:      Polyline.</li>
<li>face:      Polygon face.</li>
<li>bezier:      Bezier segments.</li>
</ul>
</li>
</ul>
<h4>Struct obj_element</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">obj_element</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">start</span><span class="p">;</span>
    <span class="n">obj_element_type</span> <span class="n">type</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Obj element vertex indices.</p>
<ul>
<li>Members:<ul>
<li>start:      Starting vertex index.</li>
<li>type:      Element type.</li>
<li>size:      Number of vertices.</li>
</ul>
</li>
</ul>
<h4>Struct obj_group</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">obj_group</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">matname</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">groupname</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">smoothing</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">obj_vertex</span><span class="o">&gt;</span> <span class="n">verts</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">obj_element</span><span class="o">&gt;</span> <span class="n">elems</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">props</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Obj element group.</p>
<ul>
<li>Members:<ul>
<li>matname:      Material name.</li>
<li>groupname:      Group name.</li>
<li>smoothing:      Smoothing.</li>
<li>verts:      Element vertices.</li>
<li>elems:      Element faces.</li>
<li>props:      Properties not explicitly handled [extension].</li>
</ul>
</li>
</ul>
<h4>Struct obj_object</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">obj_object</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">obj_group</span><span class="o">*&gt;</span> <span class="n">groups</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">props</span><span class="p">;</span>
    <span class="o">~</span><span class="n">obj_object</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Obj object.</p>
<ul>
<li>Members:<ul>
<li>name:      Name.</li>
<li>groups:      Element groups.</li>
<li>props:      Properties not explicitly handled [extension].</li>
<li>~obj_object():      Cleanup.</li>
</ul>
</li>
</ul>
<h4>Struct obj_texture_info</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">obj_texture_info</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">clamp</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">props</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Obj texture information.</p>
<ul>
<li>Members:<ul>
<li>path:      File path.</li>
<li>clamp:      Whether to clamp to the edge.</li>
<li>scale:      Scale for bump and displacement.</li>
<li>props:      Properties not explicitly handled.</li>
</ul>
</li>
</ul>
<h4>Struct obj_texture</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">obj_texture</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">datab</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">dataf</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Obj texture. Texture data is loaded only if desired.</p>
<ul>
<li>Members:<ul>
<li>path:      File path.</li>
<li>width:      Width.</li>
<li>height:      Height.</li>
<li>ncomp:      Number of Channels.</li>
<li>datab:      Buffer data for LDR images.</li>
<li>dataf:      Buffer data for HDR images.</li>
</ul>
</li>
</ul>
<h4>Struct obj_material</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">obj_material</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">illum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">ke</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">ka</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">kd</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">ks</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">kr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">kt</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="kt">float</span> <span class="n">ns</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">ior</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">op</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">obj_texture_info</span> <span class="n">ke_txt</span><span class="p">;</span>
    <span class="n">obj_texture_info</span> <span class="n">ka_txt</span><span class="p">;</span>
    <span class="n">obj_texture_info</span> <span class="n">kd_txt</span><span class="p">;</span>
    <span class="n">obj_texture_info</span> <span class="n">ks_txt</span><span class="p">;</span>
    <span class="n">obj_texture_info</span> <span class="n">kr_txt</span><span class="p">;</span>
    <span class="n">obj_texture_info</span> <span class="n">kt_txt</span><span class="p">;</span>
    <span class="n">obj_texture_info</span> <span class="n">ns_txt</span><span class="p">;</span>
    <span class="n">obj_texture_info</span> <span class="n">op_txt</span><span class="p">;</span>
    <span class="n">obj_texture_info</span> <span class="n">ior_txt</span><span class="p">;</span>
    <span class="n">obj_texture_info</span> <span class="n">bump_txt</span><span class="p">;</span>
    <span class="n">obj_texture_info</span> <span class="n">disp_txt</span><span class="p">;</span>
    <span class="n">obj_texture_info</span> <span class="n">norm_txt</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">props</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Obj material.</p>
<ul>
<li>Members:<ul>
<li>name:      Name.</li>
<li>illum:      MTL illum mode.</li>
<li>ke:      Emission color.</li>
<li>ka:      Ambient color.</li>
<li>kd:      Diffuse color.</li>
<li>ks:      Specular color.</li>
<li>kr:      Reflection color.</li>
<li>kt:      Transmision color.</li>
<li>ns:      Phong exponent for ks.</li>
<li>ior:      Index of refraction.</li>
<li>op:      Opacity.</li>
<li>ke_txt:      Emission texture.</li>
<li>ka_txt:      Ambient texture.</li>
<li>kd_txt:      Diffuse texture.</li>
<li>ks_txt:      Specular texture.</li>
<li>kr_txt:      Reflection texture.</li>
<li>kt_txt:      Transmission texture.</li>
<li>ns_txt:      Specular exponent texture.</li>
<li>op_txt:      Opacity texture.</li>
<li>ior_txt:      Index of refraction.</li>
<li>bump_txt:      Bump map texture (heighfield).</li>
<li>disp_txt:      Displacement map texture (heighfield).</li>
<li>norm_txt:      Normal map texture.</li>
<li>props:      Properties not explicitly handled.</li>
</ul>
</li>
</ul>
<h4>Struct obj_camera</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">obj_camera</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">frame3f</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">identity_frame3f</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">ortho</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">yfov</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">atan</span><span class="p">(</span><span class="mf">0.5f</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">aspect</span> <span class="o">=</span> <span class="mf">16.0f</span> <span class="o">/</span> <span class="mf">9.0f</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">aperture</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">focus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Obj camera [extension].</p>
<ul>
<li>Members:<ul>
<li>name:      Camera name.</li>
<li>frame:      Transform frame (affine matrix).</li>
<li>ortho:      Orthografic camera.</li>
<li>yfov:      Vertical field of view.</li>
<li>aspect:      Aspect ratio.</li>
<li>aperture:      Lens aperture.</li>
<li>focus:      Focus distance.</li>
</ul>
</li>
</ul>
<h4>Struct obj_environment</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">obj_environment</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">frame3f</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">identity_frame3f</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">matname</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Obj environment [extension].</p>
<ul>
<li>Members:<ul>
<li>name:      Environment name.</li>
<li>frame:      Transform frame (affine matrix).</li>
<li>matname:      Material name.</li>
</ul>
</li>
</ul>
<h4>Struct obj_node</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">obj_node</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">parent</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">camname</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">objname</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">envname</span><span class="p">;</span>
    <span class="n">frame3f</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">identity_frame3f</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">translation</span> <span class="o">=</span> <span class="n">zero3f</span><span class="p">;</span>
    <span class="n">quat4f</span> <span class="n">rotation</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">scaling</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div>


<p>Obj node [extension].</p>
<ul>
<li>Members:<ul>
<li>name:      Node name.</li>
<li>parent:      Node parent.</li>
<li>camname:      Camera name.</li>
<li>objname:      Instance name.</li>
<li>envname:      Environment name.</li>
<li>frame:      Transform frame (affine matrix).</li>
<li>translation:      Translation.</li>
<li>rotation:      Rotation.</li>
<li>scaling:      Scaling.</li>
</ul>
</li>
</ul>
<h4>Struct obj_scene</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">obj_scene</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">pos</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">norm</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span> <span class="n">texcoord</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;</span> <span class="n">color</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">radius</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">obj_object</span><span class="o">*&gt;</span> <span class="n">objects</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">obj_material</span><span class="o">*&gt;</span> <span class="n">materials</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">obj_texture</span><span class="o">*&gt;</span> <span class="n">textures</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">obj_camera</span><span class="o">*&gt;</span> <span class="n">cameras</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">obj_environment</span><span class="o">*&gt;</span> <span class="n">environments</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">obj_node</span><span class="o">*&gt;</span> <span class="n">nodes</span><span class="p">;</span>
    <span class="o">~</span><span class="n">obj_scene</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Obj scene.</p>
<ul>
<li>Members:<ul>
<li>pos:      Vertex positions.</li>
<li>norm:      Vertex normals.</li>
<li>texcoord:      Vertex texcoord.</li>
<li>color:      Vertex color [extension].</li>
<li>radius:      Vertex radius [extension].</li>
<li>objects:      Objects.</li>
<li>materials:      Materials.</li>
<li>textures:      Textures.</li>
<li>cameras:      Cameras [extension].</li>
<li>environments:      Environments [extension].</li>
<li>nodes:      Nodes [extension].</li>
<li>~obj_scene():      Cleanup.</li>
</ul>
</li>
</ul>
<h4>Function load_obj()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">obj_scene</span><span class="o">*</span> <span class="nf">load_obj</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">load_textures</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">skip_missing</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">flip_texcoord</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">flip_tr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Load an OBJ from file <code>filename</code>. Load textures if <code>load_textures</code> is true,
and report errors only if <code>skip_missing</code> is false.
Texture coordinates and material Tr are flipped if <code>flip_texcoord</code> and
<code>flip_tp</code> are respectively true.</p>
<h4>Function save_obj()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">save_obj</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">obj_scene</span><span class="o">*</span> <span class="n">model</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">save_textures</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">skip_missing</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">flip_texcoord</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">flip_tr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Save an OBJ to file <code>filename</code>. Save textures if <code>save_textures</code> is true,
and report errors only if <code>skip_missing</code> is false.
Texture coordinates and material Tr are flipped if <code>flip_texcoord</code> and
<code>flip_tp</code> are respectively true.</p>
<p><a id="toc54"></a></p>
<h3>Khronos glTF</h3>
<h4>Typedef buffer_data</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">buffer_data</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>Generic buffer data.</p>
<h4>Struct image_data</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">image_data</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">datab</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">dataf</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Generic image data.</p>
<ul>
<li>Members:<ul>
<li>width:      Width.</li>
<li>height:      Height.</li>
<li>ncomp:      Number of Channels.</li>
<li>datab:      Buffer data for 8-bit images.</li>
<li>dataf:      Buffer data for float images.</li>
</ul>
</li>
</ul>
<h4>Struct glTFid</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">glTFid</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="p">();</span> 
    <span class="k">explicit</span> <span class="nf">glTFid</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">);</span> 
    <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">bool</span> <span class="nf">is_valid</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">bool</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div>


<p>Id for glTF references.</p>
<ul>
<li>Members:<ul>
<li>glTFid():      Defaoult constructor to an invalid id.</li>
<li>glTFid():      Explicit conversion from integer.</li>
<li>operator int():      Explicit convcersion to integer.</li>
<li>is_valid():      Check if it is valid.</li>
<li>operator bool():      Check if it is valid.</li>
</ul>
</li>
</ul>
<h4>Struct glTFProperty</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">nlohmann</span><span class="o">::</span><span class="n">json</span><span class="o">&gt;</span> <span class="n">extensions</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">nlohmann</span><span class="o">::</span><span class="n">json</span> <span class="n">extras</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>Generic glTF object.</p>
<ul>
<li>Members:<ul>
<li>extensions:      Extensions.</li>
<li>extras:      Extra data.</li>
</ul>
</li>
</ul>
<h4>Struct glTFChildOfRootProperty</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFChildOfRootProperty</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Generic glTF named object</p>
<ul>
<li>Members:<ul>
<li>name:      The user-defined name of this object.</li>
</ul>
</li>
</ul>
<h4>Enum class glTFAccessorSparseIndicesComponentType</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFAccessorSparseIndicesComponentType</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFAccessorSparseIndices::componentType</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Struct glTFAccessorSparseIndices</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAccessorSparseIndices</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFBufferView</span><span class="o">&gt;</span> <span class="n">bufferView</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="kt">int</span> <span class="n">byteOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">glTFAccessorSparseIndicesComponentType</span> <span class="n">componentType</span> <span class="o">=</span>
        <span class="n">glTFAccessorSparseIndicesComponentType</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Indices of those attributes that deviate from their initialization value.</p>
<ul>
<li>Members:<ul>
<li>bufferView:      The index of the bufferView with sparse indices. Referenced bufferView
 can't have ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target. [required]</li>
<li>byteOffset:      The offset relative to the start of the bufferView in bytes. Must be
 aligned.</li>
<li>componentType:      The indices data type. [required]</li>
</ul>
</li>
</ul>
<h4>Struct glTFAccessorSparseValues</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAccessorSparseValues</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFBufferView</span><span class="o">&gt;</span> <span class="n">bufferView</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="kt">int</span> <span class="n">byteOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Array of size <code>accessor.sparse.count</code> times number of components storing the
displaced accessor attributes pointed by <code>accessor.sparse.indices</code>.</p>
<ul>
<li>Members:<ul>
<li>bufferView:      The index of the bufferView with sparse values. Referenced bufferView
 can't have ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target. [required]</li>
<li>byteOffset:      The offset relative to the start of the bufferView in bytes. Must be
 aligned.</li>
</ul>
</li>
</ul>
<h4>Struct glTFAccessorSparse</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAccessorSparse</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">glTFAccessorSparseIndices</span><span class="o">*</span> <span class="n">indices</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">glTFAccessorSparseValues</span><span class="o">*</span> <span class="n">values</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="o">~</span><span class="n">glTFAccessorSparse</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Sparse storage of attributes that deviate from their initialization value.</p>
<ul>
<li>Members:<ul>
<li>count:      Number of entries stored in the sparse array. [required]</li>
<li>indices:      Index array of size <code>count</code> that points to those accessor attributes
 that deviate from their initialization value. Indices must strictly
 increase. [required]</li>
<li>values:      Array of size <code>count</code> times number of components, storing the displaced
 accessor attributes pointed by <code>indices</code>. Substituted values must have
 the same <code>componentType</code> and number of components as the base accessor.
 [required]</li>
<li>~glTFAccessorSparse():      Cleanup</li>
</ul>
</li>
</ul>
<h4>Enum class glTFAccessorComponentType</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFAccessorComponentType</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFAccessor::componentType</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Enum class glTFAccessorType</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFAccessorType</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFAccessor::type</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Struct glTFAccessor</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAccessor</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFBufferView</span><span class="o">&gt;</span> <span class="n">bufferView</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="kt">int</span> <span class="n">byteOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">glTFAccessorComponentType</span> <span class="n">componentType</span> <span class="o">=</span> <span class="n">glTFAccessorComponentType</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">normalized</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">glTFAccessorType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">glTFAccessorType</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">max</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">min</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFAccessorSparse</span><span class="o">*</span> <span class="n">sparse</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="o">~</span><span class="n">glTFAccessor</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>A typed view into a bufferView.  A bufferView contains raw binary data.  An
accessor provides a typed view into a bufferView or a subset of a bufferView
similar to how WebGL's <code>vertexAttribPointer()</code> defines an attribute in a
buffer.</p>
<ul>
<li>Members:<ul>
<li>bufferView:      The index of the bufferView.</li>
<li>byteOffset:      The offset relative to the start of the bufferView in bytes.</li>
<li>componentType:      The datatype of components in the attribute. [required]</li>
<li>normalized:      Specifies whether integer data values should be normalized.</li>
<li>count:      The number of attributes referenced by this accessor. [required]</li>
<li>type:      Specifies if the attribute is a scalar, vector, or matrix. [required]</li>
<li>max:      Maximum value of each component in this attribute.</li>
<li>min:      Minimum value of each component in this attribute.</li>
<li>sparse:      Sparse storage of attributes that deviate from their initialization
 value.</li>
<li>~glTFAccessor():      Cleanup</li>
</ul>
</li>
</ul>
<h4>Enum class glTFAnimationChannelTargetPath</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFAnimationChannelTargetPath</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFAnimationChannelTarget::path</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Struct glTFAnimationChannelTarget</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAnimationChannelTarget</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFNode</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFAnimationChannelTargetPath</span> <span class="n">path</span> <span class="o">=</span>
        <span class="n">glTFAnimationChannelTargetPath</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>The index of the node and TRS property that an animation channel targets.</p>
<ul>
<li>Members:<ul>
<li>node:      The index of the node to target. [required]</li>
<li>path:      The name of the node's TRS property to modify, or the "weights" of the
 Morph Targets it instantiates. [required]</li>
</ul>
</li>
</ul>
<h4>Struct glTFAnimationChannel</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAnimationChannel</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAnimationSampler</span><span class="o">&gt;</span> <span class="n">sampler</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFAnimationChannelTarget</span><span class="o">*</span> <span class="n">target</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="o">~</span><span class="n">glTFAnimationChannel</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Targets an animation's sampler at a node's property.</p>
<ul>
<li>Members:<ul>
<li>sampler:      The index of a sampler in this animation used to compute the value for
 the target. [required]</li>
<li>target:      The index of the node and TRS property to target. [required]</li>
<li>~glTFAnimationChannel():      Cleanup</li>
</ul>
</li>
</ul>
<h4>Enum class glTFAnimationSamplerInterpolation</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFAnimationSamplerInterpolation</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFAnimationSampler::interpolation</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Struct glTFAnimationSampler</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAnimationSampler</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAccessor</span><span class="o">&gt;</span> <span class="n">input</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFAnimationSamplerInterpolation</span> <span class="n">interpolation</span> <span class="o">=</span>
        <span class="n">glTFAnimationSamplerInterpolation</span><span class="o">::</span><span class="n">Linear</span><span class="p">;</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAccessor</span><span class="o">&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>Combines input and output accessors with an interpolation algorithm to
define a keyframe graph (but not its target).</p>
<ul>
<li>Members:<ul>
<li>input:      The index of an accessor containing keyframe input values, e.g., time.
 [required]</li>
<li>interpolation:      Interpolation algorithm.</li>
<li>output:      The index of an accessor, containing keyframe output values. [required]</li>
</ul>
</li>
</ul>
<h4>Struct glTFAnimation</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAnimation</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFAnimationChannel</span><span class="o">*&gt;</span> <span class="n">channels</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFAnimationSampler</span><span class="o">*&gt;</span> <span class="n">samplers</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFAnimationChannel</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAnimationChannel</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFAnimationSampler</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAnimationSampler</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="o">~</span><span class="n">glTFAnimation</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>A keyframe animation.</p>
<ul>
<li>Members:<ul>
<li>channels:      An array of channels, each of which targets an animation's sampler at a
 node's property. Different channels of the same animation can't have
 equal targets. [required]</li>
<li>samplers:      An array of samplers that combines input and output accessors with an
 interpolation algorithm to define a keyframe graph (but not its target).
 [required]</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>~glTFAnimation():      Cleanup</li>
</ul>
</li>
</ul>
<h4>Struct glTFAsset</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAsset</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">copyright</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">generator</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">version</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">minVersion</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Metadata about the glTF asset.</p>
<ul>
<li>Members:<ul>
<li>copyright:      A copyright message suitable for display to credit the content creator.</li>
<li>generator:      Tool that generated this glTF model.  Useful for debugging.</li>
<li>version:      The glTF version that this asset targets. [required]</li>
<li>minVersion:      The minimum glTF version that this asset targets.</li>
</ul>
</li>
</ul>
<h4>Struct glTFBuffer</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFBuffer</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">uri</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">byteLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">buffer_data</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>A buffer points to binary geometry, animation, or skins.</p>
<ul>
<li>Members:<ul>
<li>uri:      The uri of the buffer.</li>
<li>byteLength:      The length of the buffer in bytes. [required]</li>
<li>data:      Stores buffer content after loading. [required]</li>
</ul>
</li>
</ul>
<h4>Enum class glTFBufferViewTarget</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFBufferViewTarget</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFBufferView::target</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Struct glTFBufferView</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFBufferView</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFBuffer</span><span class="o">&gt;</span> <span class="n">buffer</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="kt">int</span> <span class="n">byteOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">byteLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">byteStride</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">glTFBufferViewTarget</span> <span class="n">target</span> <span class="o">=</span> <span class="n">glTFBufferViewTarget</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>A view into a buffer generally representing a subset of the buffer.</p>
<ul>
<li>Members:<ul>
<li>buffer:      The index of the buffer. [required]</li>
<li>byteOffset:      The offset into the buffer in bytes.</li>
<li>byteLength:      The length of the bufferView in bytes. [required]</li>
<li>byteStride:      The stride, in bytes.</li>
<li>target:      The target that the GPU buffer should be bound to.</li>
</ul>
</li>
</ul>
<h4>Struct glTFCameraOrthographic</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFCameraOrthographic</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">xmag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">ymag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">zfar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">znear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>An orthographic camera containing properties to create an orthographic
projection matrix.</p>
<ul>
<li>Members:<ul>
<li>xmag:      The floating-point horizontal magnification of the view. [required]</li>
<li>ymag:      The floating-point vertical magnification of the view. [required]</li>
<li>zfar:      The floating-point distance to the far clipping plane. <code>zfar</code> must be
 greater than <code>znear</code>. [required]</li>
<li>znear:      The floating-point distance to the near clipping plane. [required]</li>
</ul>
</li>
</ul>
<h4>Struct glTFCameraPerspective</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFCameraPerspective</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">aspectRatio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">yfov</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">zfar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">znear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>A perspective camera containing properties to create a perspective
projection matrix.</p>
<ul>
<li>Members:<ul>
<li>aspectRatio:      The floating-point aspect ratio of the field of view.</li>
<li>yfov:      The floating-point vertical field of view in radians. [required]</li>
<li>zfar:      The floating-point distance to the far clipping plane.</li>
<li>znear:      The floating-point distance to the near clipping plane. [required]</li>
</ul>
</li>
</ul>
<h4>Enum class glTFCameraType</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFCameraType</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFCamera::type</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Struct glTFCamera</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFCamera</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">glTFCameraOrthographic</span><span class="o">*</span> <span class="n">orthographic</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">glTFCameraPerspective</span><span class="o">*</span> <span class="n">perspective</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">glTFCameraType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">glTFCameraType</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
    <span class="o">~</span><span class="n">glTFCamera</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>A camera's projection.  A node can reference a camera to apply a transform
to place the camera in the scene.</p>
<ul>
<li>Members:<ul>
<li>orthographic:      An orthographic camera containing properties to create an orthographic
 projection matrix.</li>
<li>perspective:      A perspective camera containing properties to create a perspective
 projection matrix.</li>
<li>type:      Specifies if the camera uses a perspective or orthographic projection.
 [required]</li>
<li>~glTFCamera():      Cleanup</li>
</ul>
</li>
</ul>
<h4>Enum class glTFImageMimeType</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFImageMimeType</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFImage::mimeType</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Struct glTFImage</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFImage</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">uri</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">glTFImageMimeType</span> <span class="n">mimeType</span> <span class="o">=</span> <span class="n">glTFImageMimeType</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFBufferView</span><span class="o">&gt;</span> <span class="n">bufferView</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">image_data</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>Image data used to create a texture. Image can be referenced by URI or
<code>bufferView</code> index. <code>mimeType</code> is required in the latter case.</p>
<ul>
<li>Members:<ul>
<li>uri:      The uri of the image.</li>
<li>mimeType:      The image's MIME type.</li>
<li>bufferView:      The index of the bufferView that contains the image. Use this instead of
 the image's uri property.</li>
<li>data:      Stores image content after loading.</li>
</ul>
</li>
</ul>
<h4>Struct glTFTextureInfo</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFTextureInfo</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFTexture</span><span class="o">&gt;</span> <span class="n">index</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="kt">int</span> <span class="n">texCoord</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Reference to a texture.</p>
<ul>
<li>Members:<ul>
<li>index:      The index of the texture. [required]</li>
<li>texCoord:      The set index of texture's TEXCOORD attribute used for texture
 coordinate mapping.</li>
</ul>
</li>
</ul>
<h4>Struct glTFTexture</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFTexture</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFSampler</span><span class="o">&gt;</span> <span class="n">sampler</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFImage</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>A texture and its sampler.</p>
<ul>
<li>Members:<ul>
<li>sampler:      The index of the sampler used by this texture. When undefined, a sampler
 with repeat wrapping and auto filtering should be used.</li>
<li>source:      The index of the image used by this texture.</li>
</ul>
</li>
</ul>
<h4>Struct glTFMaterialNormalTextureInfo</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFMaterialNormalTextureInfo</span> <span class="p">:</span> <span class="n">glTFTextureInfo</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Normal texture information.</p>
<ul>
<li>Members:<ul>
<li>scale:      The scalar multiplier applied to each normal vector of the normal
 texture.</li>
</ul>
</li>
</ul>
<h4>Struct glTFMaterialOcclusionTextureInfo</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFMaterialOcclusionTextureInfo</span> <span class="p">:</span> <span class="n">glTFTextureInfo</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">strength</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Occlusion texture information.</p>
<ul>
<li>Members:<ul>
<li>strength:      A scalar multiplier controlling the amount of occlusion applied.</li>
</ul>
</li>
</ul>
<h4>Struct glTFMaterialPbrMetallicRoughness</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFMaterialPbrMetallicRoughness</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">vec4f</span> <span class="n">baseColorFactor</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">glTFTextureInfo</span><span class="o">*</span> <span class="n">baseColorTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">metallicFactor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">roughnessFactor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">glTFTextureInfo</span><span class="o">*</span> <span class="n">metallicRoughnessTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="o">~</span><span class="n">glTFMaterialPbrMetallicRoughness</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>A set of parameter values that are used to define the metallic-roughness
material model from Physically-Based Rendering (PBR) methodology.</p>
<ul>
<li>Members:<ul>
<li>baseColorFactor:      The material's base color factor.</li>
<li>baseColorTexture:      The base color texture.</li>
<li>metallicFactor:      The metalness of the material.</li>
<li>roughnessFactor:      The roughness of the material.</li>
<li>metallicRoughnessTexture:      The metallic-roughness texture.</li>
<li>~glTFMaterialPbrMetallicRoughness():      Cleanup</li>
</ul>
</li>
</ul>
<h4>Struct glTFMaterialPbrSpecularGlossiness</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFMaterialPbrSpecularGlossiness</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">vec4f</span> <span class="n">diffuseFactor</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">glTFTextureInfo</span><span class="o">*</span> <span class="n">diffuseTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">specularFactor</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="kt">float</span> <span class="n">glossinessFactor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">glTFTextureInfo</span><span class="o">*</span> <span class="n">specularGlossinessTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="o">~</span><span class="n">glTFMaterialPbrSpecularGlossiness</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>glTF extension that defines the specular-glossiness material model from
Physically-Based Rendering (PBR) methodology.</p>
<ul>
<li>Members:<ul>
<li>diffuseFactor:      The reflected diffuse factor of the material.</li>
<li>diffuseTexture:      The diffuse texture.</li>
<li>specularFactor:      The specular RGB color of the material.</li>
<li>glossinessFactor:      The glossiness or smoothness of the material.</li>
<li>specularGlossinessTexture:      The specular-glossiness texture.</li>
<li>~glTFMaterialPbrSpecularGlossiness():      Cleanup</li>
</ul>
</li>
</ul>
<h4>Enum class glTFMaterialAlphaMode</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFMaterialAlphaMode</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFMaterial::alphaMode</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Struct glTFMaterial</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFMaterial</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">glTFMaterialPbrMetallicRoughness</span><span class="o">*</span> <span class="n">pbrMetallicRoughness</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">glTFMaterialPbrSpecularGlossiness</span><span class="o">*</span> <span class="n">pbrSpecularGlossiness</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">glTFMaterialNormalTextureInfo</span><span class="o">*</span> <span class="n">normalTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">glTFMaterialOcclusionTextureInfo</span><span class="o">*</span> <span class="n">occlusionTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">glTFTextureInfo</span><span class="o">*</span> <span class="n">emissiveTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">emissiveFactor</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">glTFMaterialAlphaMode</span> <span class="n">alphaMode</span> <span class="o">=</span> <span class="n">glTFMaterialAlphaMode</span><span class="o">::</span><span class="n">Opaque</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">alphaCutoff</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">doubleSided</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="o">~</span><span class="n">glTFMaterial</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>The material appearance of a primitive.</p>
<ul>
<li>Members:<ul>
<li>pbrMetallicRoughness:      A set of parameter values that are used to define the metallic-roughness
 material model from Physically-Based Rendering (PBR) methodology. When
 not specified, all the default values of <code>pbrMetallicRoughness</code> apply.</li>
<li>pbrSpecularGlossiness:      A set of parameter values that are used to define the
 specular-glossiness material model from Physically-Based Rendering (PBR)
 methodology. When not specified, all the default values of
 <code>pbrMetallicRoughness</code> apply.</li>
<li>normalTexture:      The normal map texture.</li>
<li>occlusionTexture:      The occlusion map texture.</li>
<li>emissiveTexture:      The emissive map texture.</li>
<li>emissiveFactor:      The emissive color of the material.</li>
<li>alphaMode:      The alpha rendering mode of the material.</li>
<li>alphaCutoff:      The alpha cutoff value of the material.</li>
<li>doubleSided:      Specifies whether the material is double sided.</li>
<li>~glTFMaterial():      Cleanup</li>
</ul>
</li>
</ul>
<h4>Enum class glTFMeshPrimitiveMode</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFMeshPrimitiveMode</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFMeshPrimitive::mode</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Struct glTFMeshPrimitive</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFMeshPrimitive</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAccessor</span><span class="o">&gt;&gt;</span> <span class="n">attributes</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAccessor</span><span class="o">&gt;</span> <span class="n">indices</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFMaterial</span><span class="o">&gt;</span> <span class="n">material</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFMeshPrimitiveMode</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">glTFMeshPrimitiveMode</span><span class="o">::</span><span class="n">Triangles</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAccessor</span><span class="o">&gt;&gt;&gt;</span> <span class="n">targets</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>Geometry to be rendered with the given material.</p>
<ul>
<li>Members:<ul>
<li>attributes:      A dictionary object, where each key corresponds to mesh attribute
 semantic and each value is the index of the accessor containing
 attribute's data. [required]</li>
<li>indices:      The index of the accessor that contains the indices.</li>
<li>material:      The index of the material to apply to this primitive when rendering.</li>
<li>mode:      The type of primitives to render.</li>
<li>targets:      An array of Morph Targets, each  Morph Target is a dictionary mapping
 attributes (only <code>POSITION</code>, <code>NORMAL</code>, and <code>TANGENT</code> supported) to their
 deviations in the Morph Target.</li>
</ul>
</li>
</ul>
<h4>Struct glTFMesh</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFMesh</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFMeshPrimitive</span><span class="o">*&gt;</span> <span class="n">primitives</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">weights</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="o">~</span><span class="n">glTFMesh</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>A set of primitives to be rendered.  A node can contain one mesh.  A node's
transform places the mesh in the scene.</p>
<ul>
<li>Members:<ul>
<li>primitives:      An array of primitives, each defining geometry to be rendered with a
 material. [required]</li>
<li>weights:      Array of weights to be applied to the Morph Targets.</li>
<li>~glTFMesh():      Cleanup</li>
</ul>
</li>
</ul>
<h4>Struct glTFNode</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFNode</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFCamera</span><span class="o">&gt;</span> <span class="n">camera</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFNode</span><span class="o">&gt;&gt;</span> <span class="n">children</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFSkin</span><span class="o">&gt;</span> <span class="n">skin</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">mat4f</span> <span class="n">matrix</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span> <span class="p">};</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFMesh</span><span class="o">&gt;</span> <span class="n">mesh</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">quat4f</span> <span class="n">rotation</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">scale</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">translation</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">weights</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>A node in the node hierarchy.  When the node contains <code>skin</code>, all
<code>mesh.primitives</code> must contain <code>JOINTS_0</code> and <code>WEIGHTS_0</code> attributes.  A
node can have either a <code>matrix</code> or any combination of
<code>translation</code>/<code>rotation</code>/<code>scale</code> (TRS) properties. TRS properties are
converted to matrices and postmultiplied in the <code>T * R * S</code> order to compose
the transformation matrix; first the scale is applied to the vertices, then
the rotation, and then the translation. If none are provided, the transform
is the identity. When a node is targeted for animation (referenced by an
animation.channel.target), only TRS properties may be present; <code>matrix</code> will
not be present.</p>
<ul>
<li>Members:<ul>
<li>camera:      The index of the camera referenced by this node.</li>
<li>children:      The indices of this node's children.</li>
<li>skin:      The index of the skin referenced by this node.</li>
<li>matrix:      A floating-point 4x4 transformation matrix stored in column-major order.</li>
<li>mesh:      The index of the mesh in this node.</li>
<li>rotation:      The node's unit quaternion rotation in the order (x, y, z, w), where w
 is the scalar.</li>
<li>scale:      The node's non-uniform scale.</li>
<li>translation:      The node's translation.</li>
<li>weights:      The weights of the instantiated Morph Target. Number of elements must
 match number of Morph Targets of used mesh.</li>
</ul>
</li>
</ul>
<h4>Enum class glTFSamplerMagFilter</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFSamplerMagFilter</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFSampler::magFilter</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Enum class glTFSamplerMinFilter</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFSamplerMinFilter</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFSampler::minFilter</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Enum class glTFSamplerWrapS</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFSamplerWrapS</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>glTFSampler::wrapS</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Enum class glTFSamplerWrapT</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFSamplerWrapT</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>glTFSampler::wrapT</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Struct glTFSampler</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFSampler</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">glTFSamplerMagFilter</span> <span class="n">magFilter</span> <span class="o">=</span> <span class="n">glTFSamplerMagFilter</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
    <span class="n">glTFSamplerMinFilter</span> <span class="n">minFilter</span> <span class="o">=</span> <span class="n">glTFSamplerMinFilter</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
    <span class="n">glTFSamplerWrapS</span> <span class="n">wrapS</span> <span class="o">=</span> <span class="n">glTFSamplerWrapS</span><span class="o">::</span><span class="n">Repeat</span><span class="p">;</span>
    <span class="n">glTFSamplerWrapT</span> <span class="n">wrapT</span> <span class="o">=</span> <span class="n">glTFSamplerWrapT</span><span class="o">::</span><span class="n">Repeat</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Texture sampler properties for filtering and wrapping modes.</p>
<ul>
<li>Members:<ul>
<li>magFilter:      Magnification filter.</li>
<li>minFilter:      Minification filter.</li>
<li>wrapS:      s wrapping mode.</li>
<li>wrapT:      t wrapping mode.</li>
</ul>
</li>
</ul>
<h4>Struct glTFScene</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFScene</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFNode</span><span class="o">&gt;&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>The root nodes of a scene.</p>
<ul>
<li>Members:<ul>
<li>nodes:      The indices of each root node.</li>
</ul>
</li>
</ul>
<h4>Struct glTFSkin</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFSkin</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAccessor</span><span class="o">&gt;</span> <span class="n">inverseBindMatrices</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFNode</span><span class="o">&gt;</span> <span class="n">skeleton</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFNode</span><span class="o">&gt;&gt;</span> <span class="n">joints</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>Joints and matrices defining a skin.</p>
<ul>
<li>Members:<ul>
<li>inverseBindMatrices:      The index of the accessor containing the floating-point 4x4 inverse-bind
 matrices.  The default is that each matrix is a 4x4 identity matrix,
 which implies that inverse-bind matrices were pre-applied.</li>
<li>skeleton:      The index of the node used as a skeleton root. When undefined, joints
 transforms resolve to scene root.</li>
<li>joints:      Indices of skeleton nodes, used as joints in this skin. [required]</li>
</ul>
</li>
</ul>
<h4>Struct glTF</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTF</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">extensionsUsed</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">extensionsRequired</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFAccessor</span><span class="o">*&gt;</span> <span class="n">accessors</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFAnimation</span><span class="o">*&gt;</span> <span class="n">animations</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFAsset</span><span class="o">*</span> <span class="n">asset</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFBuffer</span><span class="o">*&gt;</span> <span class="n">buffers</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFBufferView</span><span class="o">*&gt;</span> <span class="n">bufferViews</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFCamera</span><span class="o">*&gt;</span> <span class="n">cameras</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFImage</span><span class="o">*&gt;</span> <span class="n">images</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFMaterial</span><span class="o">*&gt;</span> <span class="n">materials</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFMesh</span><span class="o">*&gt;</span> <span class="n">meshes</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFNode</span><span class="o">*&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFSampler</span><span class="o">*&gt;</span> <span class="n">samplers</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFScene</span><span class="o">&gt;</span> <span class="n">scene</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFScene</span><span class="o">*&gt;</span> <span class="n">scenes</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFSkin</span><span class="o">*&gt;</span> <span class="n">skins</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFTexture</span><span class="o">*&gt;</span> <span class="n">textures</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFAccessor</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAccessor</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFAnimation</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAnimation</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFBuffer</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFBuffer</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFBufferView</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFBufferView</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFCamera</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFCamera</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFImage</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFImage</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFMaterial</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFMaterial</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFMesh</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFMesh</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFNode</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFNode</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFSampler</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFSampler</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFScene</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFScene</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFSkin</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFSkin</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFTexture</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFTexture</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="o">~</span><span class="n">glTF</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>The root object for a glTF asset.</p>
<ul>
<li>Members:<ul>
<li>extensionsUsed:      Names of glTF extensions used somewhere in this asset.</li>
<li>extensionsRequired:      Names of glTF extensions required to properly load this asset.</li>
<li>accessors:      An array of accessors.</li>
<li>animations:      An array of keyframe animations.</li>
<li>asset:      Metadata about the glTF asset. [required]</li>
<li>buffers:      An array of buffers.</li>
<li>bufferViews:      An array of bufferViews.</li>
<li>cameras:      An array of cameras.</li>
<li>images:      An array of images.</li>
<li>materials:      An array of materials.</li>
<li>meshes:      An array of meshes.</li>
<li>nodes:      An array of nodes.</li>
<li>samplers:      An array of samplers.</li>
<li>scene:      The index of the default scene.</li>
<li>scenes:      An array of scenes.</li>
<li>skins:      An array of skins.</li>
<li>textures:      An array of textures.</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>~glTF():      Cleanup</li>
</ul>
</li>
</ul>
<h4>Function load_gltf()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">glTF</span><span class="o">*</span> <span class="nf">load_gltf</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">load_bin</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">load_img</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">skip_missing</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Load a gltf file <code>filename</code> from disk. Load binaries and images only if
<code>load_bin</code> and <code>load_img</code> are true, reporting errors only if <code>skip_missing</code>
is false.</p>
<h4>Function load_binary_gltf()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">glTF</span><span class="o">*</span> <span class="nf">load_binary_gltf</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">load_bin</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">load_img</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">skip_missing</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Load a binary gltf file <code>filename</code> from disk. Load binaries and images only
if <code>load_bin</code> and <code>load_img</code> are true, reporting errors only if
<code>skip_missing</code> is false.</p>
<h4>Function save_gltf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">save_gltf</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">glTF</span><span class="o">*</span> <span class="n">gltf</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">save_bin</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">save_img</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Save a gltf file <code>filename</code> to disk. Save binaries and images only if
<code>save_bin</code> and <code>save_img</code> are true.</p>
<h4>Function save_binary_gltf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">save_binary_gltf</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">glTF</span><span class="o">*</span> <span class="n">gltf</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">save_bin</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">save_img</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Save a gltf file <code>filename</code> to disk. Save binaries and images only if
<code>save_bin</code> and <code>save_img</code> are true.</p>
<h4>Function node_transform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span> <span class="nf">node_transform</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFNode</span><span class="o">*</span> <span class="n">node</span><span class="p">);</span>
</code></pre></div>


<p>Computes the local node transform and its inverse.</p>
<h4>Struct accessor_view</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">accessor_view</span> <span class="p">{</span>
    <span class="n">accessor_view</span><span class="p">(</span><span class="k">const</span> <span class="n">glTF</span><span class="o">*</span> <span class="n">gltf</span><span class="p">,</span> <span class="k">const</span> <span class="n">glTFAccessor</span><span class="o">*</span> <span class="n">accessor</span><span class="p">);</span> 
    <span class="kt">int</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="nf">count</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="nf">ncomp</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">bool</span> <span class="nf">valid</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec2f</span> <span class="n">getv2f</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">def</span> <span class="o">=</span><span class="p">;</span> 
    <span class="n">vec3f</span> <span class="n">getv3f</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">def</span> <span class="o">=</span><span class="p">;</span> 
    <span class="n">vec4f</span> <span class="n">getv4f</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">def</span> <span class="o">=</span><span class="p">;</span> 
    <span class="n">mat4f</span> <span class="nf">getm4f</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">float</span> <span class="nf">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec2i</span> <span class="n">getv2i</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">def</span> <span class="o">=</span><span class="p">;</span> 
    <span class="n">vec3i</span> <span class="n">getv3i</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">def</span> <span class="o">=</span><span class="p">;</span> 
    <span class="n">vec4i</span> <span class="n">getv4i</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">def</span> <span class="o">=</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="nf">geti</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div>


<p>A view for gltf array buffers that allows for typed access.</p>
<ul>
<li>Members:<ul>
<li>accessor_view():      Construct a view from an accessor.</li>
<li>size():      Number of elements in the view.</li>
<li>count():      Number of elements in the view</li>
<li>ncomp():      Number of components per element</li>
<li>valid():      Check whether the view is valid.</li>
<li>getv2f():      Get the idx-th element of fixed length width default values.</li>
<li>getv3f():      Get the idx-th element of fixed length width default values.</li>
<li>getv4f():      Get the idx-th element of fixed length width default values.</li>
<li>getm4f():      Get the idx-th element of fixed length as a matrix.</li>
<li>get():      Get the c-th component of the idx-th element.</li>
<li>getv2i():      Get the idx-th element as integer with fixed length.</li>
<li>getv3i():      Get the idx-th element as integer with fixed length.</li>
<li>getv4i():      Get the idx-th element as integer with fixed length.</li>
<li>geti():      Get the c-th component of the idx-th element as integer.</li>
</ul>
</li>
</ul>
<p><a id="toc55"></a></p>
<h3>Svg</h3>
<h4>Struct svg_path</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">svg_path</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Svg path.</p>
<ul>
<li>Members:<ul>
<li>pos:      Path vertices.</li>
</ul>
</li>
</ul>
<h4>Struct svg_shape</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">svg_shape</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">svg_path</span><span class="o">*&gt;</span> <span class="n">paths</span><span class="p">;</span>
    <span class="o">~</span><span class="n">svg_shape</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Svg shape.</p>
<ul>
<li>Members:<ul>
<li>paths:      Paths.</li>
<li>~svg_shape():      Cleanup.</li>
</ul>
</li>
</ul>
<h4>Struct svg_scene</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">svg_scene</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">svg_shape</span><span class="o">*&gt;</span> <span class="n">shapes</span><span class="p">;</span>
    <span class="o">~</span><span class="n">svg_scene</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Svg scene.</p>
<ul>
<li>Members:<ul>
<li>shapes:      Shapes</li>
<li>~svg_scene():      Cleanup.</li>
</ul>
</li>
</ul>
<h4>Function load_svg()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">svg_scene</span><span class="o">*</span> <span class="nf">load_svg</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>
</code></pre></div>


<p>Load an SVG.</p>
<h4>Function save_svg()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">save_svg</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">svg_scene</span><span class="o">*</span> <span class="n">svg</span><span class="p">);</span>
</code></pre></div>


<p>Save an SVG.</p>
<p><a id="toc56"></a></p>
<h3>String, path and file functions</h3>
<h4>Function startswith()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">startswith</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">substr</span><span class="p">);</span>
</code></pre></div>


<p>Checks if a string starts with a prefix.</p>
<h4>Function endswith()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">endswith</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">substr</span><span class="p">);</span>
</code></pre></div>


<p>Checks if a string ends with a prefix.</p>
<h4>Function contains()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">substr</span><span class="p">);</span>
</code></pre></div>


<p>Check is a string contains a substring.</p>
<h4>Function splitlines()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">splitlines</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keep_newline</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Splits a string into lines at the '\n' character. The line
terminator is kept if keep_newline. This function does not work on
Window if keep_newline is true.</p>
<h4>Function partition()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">partition</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">split</span><span class="p">);</span>
</code></pre></div>


<p>Partition the string.</p>
<h4>Function split()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">split</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</code></pre></div>


<p>Splits the string.</p>
<h4>Function split()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">split</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">substr</span><span class="p">);</span>
</code></pre></div>


<p>Splits the string.</p>
<h4>Function split()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">split</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="kt">char</span> <span class="n">substr</span><span class="p">);</span>
</code></pre></div>


<p>Splits the string.</p>
<h4>Function rstrip()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">rstrip</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</code></pre></div>


<p>Strip the string.</p>
<h4>Function lstrip()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">lstrip</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</code></pre></div>


<p>Strip the string.</p>
<h4>Function strip()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">strip</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</code></pre></div>


<p>Strip the string.</p>
<h4>Function join()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">join</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">strs</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">sep</span><span class="p">);</span>
</code></pre></div>


<p>Joins a list of string with a string as separator.</p>
<h4>Function lower()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">lower</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</code></pre></div>


<p>Converts an ASCII string to lowercase.</p>
<h4>Function upper()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">upper</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</code></pre></div>


<p>Converts an ASCII string to uppercase.</p>
<h4>Function isspace()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">isspace</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</code></pre></div>


<p>Check if a string is space.</p>
<h4>Function replace()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">replace</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s2</span><span class="p">);</span>
</code></pre></div>


<p>Replace s1 with s2 in str.</p>
<h4>Function path_dirname()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path_dirname</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>
</code></pre></div>


<p>Get directory name (including '/').</p>
<h4>Function path_extension()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path_extension</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>
</code></pre></div>


<p>Get extension (including '.').</p>
<h4>Function path_basename()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path_basename</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>
</code></pre></div>


<p>Get file basename.</p>
<h4>Function path_filename()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path_filename</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>
</code></pre></div>


<p>Get filename without directory (equiv to get_basename() +
get_extension()).</p>
<h4>Function replace_path_extension()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">replace_path_extension</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">ext</span><span class="p">);</span>
</code></pre></div>


<p>Replace extension.</p>
<h4>Function prepend_path_extension()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">prepend_path_extension</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">prep</span><span class="p">);</span>
</code></pre></div>


<p>Prepend a string to the extension.</p>
<h4>Function split_path()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">split_path</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">dirname</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">basename</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">ext</span><span class="p">);</span>
</code></pre></div>


<p>Splits a path calling the above functions.</p>
<h4>Function path_convert_eparator()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path_convert_eparator</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">path_</span><span class="p">);</span>
</code></pre></div>


<p>Convert from Windows to Unix/OsX path separator</p>
<h4>Function format()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">format</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Really-minimal Python like string format. The implementation is not fast
nor memory efficient. But it is good enough for some needs.</p>
<h4>Function format()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">format</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Really-minimal Python like string format. Internally uses streams for
generality and supports for now only the '{}' operator. The implementation
is not fast nor memory efficient. But it is good enough for some needs.</p>
<h4>Function print()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Wrapper for the above function that prints to stdout.</p>
<h4>Function println()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">println</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Wrapper for the above function that prints to stdout with endline.</p>
<p><a id="toc57"></a></p>
<h3>File loading and saving</h3>
<h4>Function load_binary()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">load_binary</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>
</code></pre></div>


<p>Loads the contents of a binary file in an in-memory array.</p>
<h4>Function load_text()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">load_text</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>
</code></pre></div>


<p>Loads the contents of a text file into a string.</p>
<h4>Function save_binary()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_binary</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">);</span>
</code></pre></div>


<p>Saves binary data to a file.</p>
<h4>Function save_text()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_text</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</code></pre></div>


<p>Saves a string to a text file.</p>
<p><a id="toc58"></a></p>
<h3>Immediate-mode command line parser</h3>
<h4>Struct cmdline_parser</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">cmdline_parser</span> <span class="p">{</span>
</code></pre></div>


<p>Immediate mode command line parser. Members are not part of the public API.</p>
<h4>Function should_exit()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">should_exit</span><span class="p">(</span><span class="n">cmdline_parser</span><span class="o">&amp;</span> <span class="n">parser</span><span class="p">);</span>
</code></pre></div>


<p>Check unused arguments.</p>
<h4>Function get_usage()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">get_usage</span><span class="p">(</span><span class="k">const</span> <span class="n">cmdline_parser</span><span class="o">&amp;</span> <span class="n">parser</span><span class="p">);</span>
</code></pre></div>


<p>Returns the usage string.</p>
<h4>Function parse_flag()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">parse_flag</span><span class="p">(</span><span class="n">cmdline_parser</span><span class="o">&amp;</span> <span class="n">parser</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">flag</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">help</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">def</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">req</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Pase a flag from the command line.</p>
<h4>Function parse_opt()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">parse_opt</span><span class="p">(</span><span class="n">cmdline_parser</span><span class="o">&amp;</span> <span class="n">parser</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">flag</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">help</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">def</span> <span class="o">=</span><span class="p">;</span>
</code></pre></div>


<p>Pase an option from the command line.</p>
<h4>Function parse_opt()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">parse_opt</span><span class="p">(</span><span class="n">cmdline_parser</span><span class="o">&amp;</span> <span class="n">parser</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">flag</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">help</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;&amp;</span> <span class="n">key_values</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">def</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">req</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">choices</span> <span class="o">=</span><span class="p">;</span>
</code></pre></div>


<p>Parse an enum option from the command line.</p>
<h4>Function parse_arg()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">parse_arg</span><span class="p">(</span><span class="n">cmdline_parser</span><span class="o">&amp;</span> <span class="n">parser</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">help</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">def</span> <span class="o">=</span><span class="p">;</span>
</code></pre></div>


<p>Parse positional argument from the command line.</p>
<h4>Function parse_args()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">parse_args</span><span class="p">(</span><span class="n">cmdline_parser</span><span class="o">&amp;</span> <span class="n">parser</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">help</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">def</span> <span class="o">=</span><span class="p">;</span>
</code></pre></div>


<p>Parse all remaining positional argument from the command line.</p>
<h4>Function parse_params()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">parse_params</span><span class="p">(</span><span class="n">cmdline_parser</span><span class="o">&amp;</span> <span class="n">parser</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">def</span> <span class="o">=</span><span class="p">;</span>
</code></pre></div>


<p>Parse options generated with a visit over the parameters</p>
<h4>Function make_parser()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">cmdline_parser</span> <span class="nf">make_parser</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">help</span><span class="p">);</span>
</code></pre></div>


<p>Initialize a command line parser.</p>
<p><a id="toc59"></a></p>
<h3>Simple logging</h3>
<h4>Struct logger</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">logger</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">_verbose</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">_console</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">_file</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Logger object. A logger can output messages to console an a file.
Members are not part of the public API.</p>
<ul>
<li>Members:<ul>
<li>_verbose:      whether to output verbose</li>
<li>_console:      whether to output to console</li>
<li>_file:      file stream for stream output</li>
</ul>
</li>
</ul>
<h4>Function make_logger()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">logger</span><span class="o">*</span> <span class="nf">make_logger</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">console</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">verbose</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">file_append</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Make a logger with an optional console stream, an optional file stram
and the specified verbosity level.</p>
<h4>Function get_default_logger()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">logger</span><span class="o">*</span> <span class="nf">get_default_logger</span><span class="p">();</span>
</code></pre></div>


<p>Get the default logger.</p>
<h4>Function log_info()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">log_info</span><span class="p">(</span><span class="n">logger</span><span class="o">*</span> <span class="n">lgr</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Log an info message.</p>
<h4>Function log_warning()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">log_warning</span><span class="p">(</span>
    <span class="n">logger</span><span class="o">*</span> <span class="n">lgr</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Log an info message.</p>
<h4>Function log_error()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">log_error</span><span class="p">(</span>
    <span class="n">logger</span><span class="o">*</span> <span class="n">lgr</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Log an error message.</p>
<h4>Function log_fatal()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">log_fatal</span><span class="p">(</span>
    <span class="n">logger</span><span class="o">*</span> <span class="n">lgr</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Log a fatal message and exit.</p>
<h4>Function log_info()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">log_info</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Logs a message to the default loggers.</p>
<h4>Function log_error()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">log_error</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Logs a message to the default loggers.</p>
<h4>Function log_fatal()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">log_fatal</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Logs a message to the default loggers.</p>
<p><a id="toc60"></a></p>
<h3>Simple timer</h3>
<h4>Struct timer</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">timer</span> <span class="p">{</span>
    <span class="n">timer</span><span class="p">(</span><span class="kt">bool</span> <span class="n">autostart</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span> 
    <span class="kt">void</span> <span class="nf">start</span><span class="p">();</span> 
    <span class="kt">void</span> <span class="nf">stop</span><span class="p">();</span> 
    <span class="kt">double</span> <span class="nf">elapsed</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>A simple wrapper for std::chrono.</p>
<ul>
<li>Members:<ul>
<li>timer():      Initialize a timer and start it if necessary.</li>
<li>start():      Start a timer.</li>
<li>stop():      Stops a timer.</li>
<li>elapsed():      Elapsed time.</li>
</ul>
</li>
</ul>
<p><a id="toc61"></a></p>
<h3>OpenGL objects and utilities</h3>
<h4>Enum gl_elem_type : int</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="nl">gl_elem_type</span> <span class="p">:</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="n">point</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">line</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">triangle</span> <span class="o">=</span> <span class="mi">3</span>

<span class="p">}</span>
</code></pre></div>


<p>OpenGL shape element types.</p>
<ul>
<li>Values:<ul>
<li>point:      Points.</li>
<li>line:      Lines.</li>
<li>triangle:      Triangles.</li>
</ul>
</li>
</ul>
<h4>Enum gl_light_type : int</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="nl">gl_light_type</span> <span class="p">:</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="n">point</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">directional</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>OpenGL light types.</p>
<ul>
<li>Values:<ul>
<li>point:      Point lights.</li>
<li>directional:      Directional lights.</li>
</ul>
</li>
</ul>
<h4>Struct gl_lights</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gl_lights</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">pos</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">ke</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">gl_light_type</span><span class="o">&gt;</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>OpenGL lights</p>
<ul>
<li>Members:<ul>
<li>pos:      light positions.</li>
<li>ke:      Light intensities.</li>
<li>type:      Light types.</li>
</ul>
</li>
</ul>
<h4>Function gl_check_error()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">gl_check_error</span><span class="p">(</span><span class="kt">bool</span> <span class="n">print</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Checks for GL error and then prints.</p>
<h4>Function gl_clear_buffers()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="n">gl_clear_buffers</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">background</span> <span class="o">=</span><span class="p">;</span>
</code></pre></div>


<p>Clear window.</p>
<h4>Function gl_enable_depth_test()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">gl_enable_depth_test</span><span class="p">(</span><span class="kt">bool</span> <span class="n">enabled</span><span class="p">);</span>
</code></pre></div>


<p>Enable/disable depth test.</p>
<h4>Function gl_enable_culling()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">gl_enable_culling</span><span class="p">(</span><span class="kt">bool</span> <span class="n">enabled</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">front</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">back</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Enable/disable culling.</p>
<h4>Function gl_enable_wireframe()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">gl_enable_wireframe</span><span class="p">(</span><span class="kt">bool</span> <span class="n">enabled</span><span class="p">);</span>
</code></pre></div>


<p>Enable/disable wireframe.</p>
<h4>Function gl_enable_blending()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">gl_enable_blending</span><span class="p">(</span><span class="kt">bool</span> <span class="n">enabled</span><span class="p">);</span>
</code></pre></div>


<p>Enable/disable blending.</p>
<h4>Function gl_set_blend_over()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">gl_set_blend_over</span><span class="p">();</span>
</code></pre></div>


<p>Set blending to over operator.</p>
<h4>Function gl_line_width()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">gl_line_width</span><span class="p">(</span><span class="kt">float</span> <span class="n">w</span><span class="p">);</span>
</code></pre></div>


<p>Line width.</p>
<h4>Function gl_set_viewport()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">gl_set_viewport</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>Set viewport.</p>
<h4>Function gl_set_viewport()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">gl_set_viewport</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>Set viewport.</p>
<h4>Function gl_read_imagef()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">gl_read_imagef</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">pixels</span><span class="p">,</span> <span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nc</span><span class="p">);</span>
</code></pre></div>


<p>Reads an image from the the framebuffer.</p>
<h4>Struct gl_texture</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gl_texture</span> <span class="p">{</span>
</code></pre></div>


<p>OpenGL texture object. Members are not part of the public API.</p>
<h4>Function update_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_texture</span><span class="p">(</span><span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nc</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">pixels</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">linear</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">mipmap</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">as_float</span><span class="p">);</span>
</code></pre></div>


<p>Updates a texture with pixels values of size w, h with nc number of
components (1-4). Internally use float if as_float and filtering if filter.</p>
<h4>Function update_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_texture</span><span class="p">(</span><span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nc</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pixels</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">linear</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">mipmap</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">as_srgb</span><span class="p">);</span>
</code></pre></div>


<p>Updates a texture with pixels values of size w, h with nc number of
components (1-4). Internally use float if as_float and filtering if filter.</p>
<h4>Function update_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_texture</span><span class="p">(</span><span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">,</span> <span class="k">const</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">linear</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">mipmap</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">as_float</span><span class="p">);</span>
</code></pre></div>


<p>Updates a texture with pixels values from an image.
Internally use float if as_float and filtering if filter.</p>
<h4>Function update_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_texture</span><span class="p">(</span><span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">,</span> <span class="k">const</span> <span class="n">image4b</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">linear</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">mipmap</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">as_srgb</span><span class="p">);</span>
</code></pre></div>


<p>Updates a texture with pixels values from an image.
Internally use float if as_float and filtering if filter.</p>
<h4>Function update_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_texture</span><span class="p">(</span><span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">,</span> <span class="k">const</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">);</span>
</code></pre></div>


<p>Updates a texture with pixels values from an image.</p>
<h4>Function update_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_texture</span><span class="p">(</span><span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">,</span> <span class="k">const</span> <span class="n">image4b</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">);</span>
</code></pre></div>


<p>Updates a texture with pixels values from an image.</p>
<h4>Function make_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">gl_texture</span> <span class="nf">make_texture</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">linear</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">mipmap</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">as_float</span><span class="p">);</span>
</code></pre></div>


<p>Creates a texture from an image. Convenience wrapper to update_texture().</p>
<h4>Function make_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">gl_texture</span> <span class="nf">make_texture</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">image4b</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">linear</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">mipmap</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">as_srgb</span><span class="p">);</span>
</code></pre></div>


<p>Creates a texture from an image. Convenience wrapper to update_texture().</p>
<h4>Function bind_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">bind_texture</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">,</span> <span class="n">uint</span> <span class="n">unit</span><span class="p">);</span>
</code></pre></div>


<p>Binds a texture to a texture unit.</p>
<h4>Function unbind_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">unbind_texture</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">,</span> <span class="n">uint</span> <span class="n">unit</span><span class="p">);</span>
</code></pre></div>


<p>Unbinds a texture.</p>
<h4>Function get_texture_id()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">uint</span> <span class="nf">get_texture_id</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">);</span>
</code></pre></div>


<p>Get texture id.</p>
<h4>Function is_texture_valid()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_texture_valid</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">);</span>
</code></pre></div>


<p>Check if defined.</p>
<h4>Function clear_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">clear_texture</span><span class="p">(</span><span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">);</span>
</code></pre></div>


<p>Destroys the texture tid.</p>
<h4>Enum gl_texture_wrap</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">gl_texture_wrap</span> <span class="p">{</span>
    <span class="n">not_set</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">repeat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">clamp</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">mirror</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Wrap values for OpenGL texture.</p>
<ul>
<li>Values:<ul>
<li>not_set:      Not set.</li>
<li>repeat:      Repeat.</li>
<li>clamp:      Clamp to edge.</li>
<li>mirror:      Mirror.</li>
</ul>
</li>
</ul>
<h4>Enum gl_texture_filter</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">gl_texture_filter</span> <span class="p">{</span>
    <span class="n">not_set</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">linear</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">nearest</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">linear_mipmap_linear</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">nearest_mipmap_nearest</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">linear_mipmap_nearest</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">nearest_mipmap_linear</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Filter values for OpenGL texture.</p>
<ul>
<li>Values:<ul>
<li>not_set:      Not set.</li>
<li>linear:      Linear.</li>
<li>nearest:      Nearest.</li>
<li>linear_mipmap_linear:      Mip-mapping.</li>
<li>nearest_mipmap_nearest:      Mip-mapping.</li>
<li>linear_mipmap_nearest:      Mip-mapping.</li>
<li>nearest_mipmap_linear:      Mip-mapping.</li>
</ul>
</li>
</ul>
<h4>Struct gl_texture_info</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gl_texture_info</span> <span class="p">{</span>
    <span class="n">gl_texture</span> <span class="n">txt</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="kt">int</span> <span class="n">texcoord</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">gl_texture_wrap</span> <span class="n">wrap_s</span> <span class="o">=</span> <span class="n">gl_texture_wrap</span><span class="o">::</span><span class="n">not_set</span><span class="p">;</span>
    <span class="n">gl_texture_wrap</span> <span class="n">wrap_t</span> <span class="o">=</span> <span class="n">gl_texture_wrap</span><span class="o">::</span><span class="n">not_set</span><span class="p">;</span>
    <span class="n">gl_texture_filter</span> <span class="n">filter_mag</span> <span class="o">=</span> <span class="n">gl_texture_filter</span><span class="o">::</span><span class="n">not_set</span><span class="p">;</span>
    <span class="n">gl_texture_filter</span> <span class="n">filter_min</span> <span class="o">=</span> <span class="n">gl_texture_filter</span><span class="o">::</span><span class="n">not_set</span><span class="p">;</span>
    <span class="n">gl_texture_info</span><span class="p">();</span> 
    <span class="n">gl_texture_info</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">tid</span><span class="p">);</span> 
<span class="p">}</span>
</code></pre></div>


<p>OpenGL texture parameters.</p>
<ul>
<li>Members:<ul>
<li>txt:      Texture.</li>
<li>texcoord:      Texture coordinate set.</li>
<li>scale:      Texture strength/scale (used by some models).</li>
<li>wrap_s:      Wrap s mode.</li>
<li>wrap_t:      Wrap t mode</li>
<li>filter_mag:      Filter mag mode.</li>
<li>filter_min:      Filter min mode.</li>
<li>gl_texture_info():      Default constructor.</li>
<li>gl_texture_info():      Constructor from texture id only.</li>
</ul>
</li>
</ul>
<h4>Struct gl_vertex_buffer</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gl_vertex_buffer</span> <span class="p">{</span>
</code></pre></div>


<p>OpenGL vertex/element buffer. Members are not part of the public API.</p>
<h4>Function update_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_vertex_buffer</span><span class="p">(</span><span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncomp</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer with new data.</p>
<h4>Function update_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_vertex_buffer</span><span class="p">(</span><span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncomp</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer with new data.</p>
<h4>Function update_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_vertex_buffer</span><span class="p">(</span><span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer with new data.</p>
<h4>Function update_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_vertex_buffer</span><span class="p">(</span><span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer with new data.</p>
<h4>Function update_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_vertex_buffer</span><span class="p">(</span><span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer with new data.</p>
<h4>Function update_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_vertex_buffer</span><span class="p">(</span><span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer with new data.</p>
<h4>Function update_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_vertex_buffer</span><span class="p">(</span><span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer with new data.</p>
<h4>Function update_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_vertex_buffer</span><span class="p">(</span><span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer with new data.</p>
<h4>Function update_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_vertex_buffer</span><span class="p">(</span><span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer with new data.</p>
<h4>Function update_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_vertex_buffer</span><span class="p">(</span><span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer with new data.</p>
<h4>Function make_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">gl_vertex_buffer</span> <span class="n">make_vertex_buffer</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Make a buffer with new data.</p>
<h4>Function bind_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">bind_vertex_buffer</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="n">uint</span> <span class="n">vattr</span><span class="p">);</span>
</code></pre></div>


<p>Bind the buffer at a particular attribute location.</p>
<h4>Function unbind_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">unbind_vertex_buffer</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="n">uint</span> <span class="n">vattr</span><span class="p">);</span>
</code></pre></div>


<p>Unbind the buffer.</p>
<h4>Function unbind_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">unbind_vertex_buffer</span><span class="p">(</span><span class="n">uint</span> <span class="n">vattr</span><span class="p">);</span>
</code></pre></div>


<p>Unbind the buffer.</p>
<h4>Function get_vertex_buffer_id()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">uint</span> <span class="nf">get_vertex_buffer_id</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">);</span>
</code></pre></div>


<p>Get buffer id.</p>
<h4>Function is_vertex_buffer_valid()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_vertex_buffer_valid</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">);</span>
</code></pre></div>


<p>Check if defined.</p>
<h4>Function clear_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">clear_vertex_buffer</span><span class="p">(</span><span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">);</span>
</code></pre></div>


<p>Destroys the buffer.</p>
<h4>Struct gl_element_buffer</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gl_element_buffer</span> <span class="p">{</span>
    <span class="n">uint</span> <span class="n">bid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>OpenGL element array buffer. Members are not part of the public API.</p>
<ul>
<li>Members:<ul>
<li>bid:      Buffer id.</li>
<li>num:      Number of elements.</li>
<li>ncomp:      Number of components.</li>
</ul>
</li>
</ul>
<h4>Function update_element_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_element_buffer</span><span class="p">(</span><span class="n">gl_element_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncomp</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer with new data.</p>
<h4>Function update_element_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_element_buffer</span><span class="p">(</span><span class="n">gl_element_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Updates the bufferwith new data.</p>
<h4>Function update_element_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_element_buffer</span><span class="p">(</span><span class="n">gl_element_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer with new data.</p>
<h4>Function update_element_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_element_buffer</span><span class="p">(</span><span class="n">gl_element_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer with new data.</p>
<h4>Function update_element_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_element_buffer</span><span class="p">(</span><span class="n">gl_element_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer with new data.</p>
<h4>Function make_element_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">gl_element_buffer</span> <span class="n">make_element_buffer</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Make a buffer with new data.</p>
<h4>Function draw_elems()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_elems</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_element_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">);</span>
</code></pre></div>


<p>Draws elements.</p>
<h4>Function get_element_buffer_id()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">uint</span> <span class="nf">get_element_buffer_id</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_element_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">);</span>
</code></pre></div>


<p>Get id</p>
<h4>Function is_element_buffer_valid()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_element_buffer_valid</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_element_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">);</span>
</code></pre></div>


<p>Check if defined</p>
<h4>Function clear_element_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">clear_element_buffer</span><span class="p">(</span><span class="n">gl_element_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">);</span>
</code></pre></div>


<p>Destroys the buffer</p>
<h4>Struct gl_program</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gl_program</span> <span class="p">{</span>
    <span class="n">uint</span> <span class="n">pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">vid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">fid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">vao</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>OpenGL program. Members are not part of the public API.</p>
<ul>
<li>Members:<ul>
<li>pid:      Program id.</li>
<li>vid:      Vertex shader id.</li>
<li>fid:      Fragment shader id.</li>
<li>vao:      Vertex array object.</li>
</ul>
</li>
</ul>
<h4>Function make_program()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">gl_program</span> <span class="nf">make_program</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">vertex</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">fragment</span><span class="p">);</span>
</code></pre></div>


<p>Creates an OpenGL program from vertex and fragment code.</p>
<h4>Function clear_program()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">clear_program</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">);</span>
</code></pre></div>


<p>Destroys the program.</p>
<h4>Function get_program_uniform_location()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">int</span> <span class="nf">get_program_uniform_location</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">);</span>
</code></pre></div>


<p>Get uniform location.</p>
<h4>Function get_program_attrib_location()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">int</span> <span class="nf">get_program_attrib_location</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">);</span>
</code></pre></div>


<p>Get attribute location.</p>
<h4>Function get_program_uniforms_names()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">get_program_uniforms_names</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">);</span>
</code></pre></div>


<p>Get the names of all uniforms.</p>
<h4>Function get_program_attributes_names()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">get_program_attributes_names</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">);</span>
</code></pre></div>


<p>Get the names of all attributes.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncomp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform integer values <code>val</code> for program <code>prog</code> and variable <code>pos</code>.
The values have <code>nc</code> number of components (1-4) and <code>count</code> elements.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncomp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform float values <code>val</code> for program <code>prog</code> and variable <code>pos</code>.
The values have <code>nc</code> number of components (1-4) and <code>count</code> elements.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform value.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform value.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="kt">float</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform value.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform value.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform value.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform value.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform array.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform array.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;*</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform array.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;*</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform array.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">frame</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;*</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform array.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform value for names variable.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform array for names variable.</p>
<h4>Function set_program_uniform_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">set_program_uniform_texture</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_texture_info</span><span class="o">&amp;</span> <span class="n">tinfo</span><span class="p">,</span> <span class="n">uint</span> <span class="n">tunit</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform texture.</p>
<h4>Function set_program_uniform_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform_texture</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="kt">int</span> <span class="n">varon</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_texture_info</span><span class="o">&amp;</span> <span class="n">tinfo</span><span class="p">,</span> <span class="n">uint</span> <span class="n">tunit</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform texture with an additionasl texture enable flags.</p>
<h4>Function set_program_uniform_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform_texture</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_texture_info</span><span class="o">&amp;</span> <span class="n">tinfo</span><span class="p">,</span> <span class="n">uint</span> <span class="n">tunit</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform texture.</p>
<h4>Function set_program_uniform_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform_texture</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">varon</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_texture_info</span><span class="o">&amp;</span> <span class="n">tinfo</span><span class="p">,</span> <span class="n">uint</span> <span class="n">tunit</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform texture with an additionasl texture enable flags.</p>
<h4>Function set_program_vertattr()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">set_program_vertattr</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nc</span><span class="p">);</span>
</code></pre></div>


<p>Sets a constant <code>value</code> of <code>nc</code> components for the vertex attribute at
<code>pos</code> location.</p>
<h4>Function set_program_vertattr()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">set_program_vertattr</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nc</span><span class="p">);</span>
</code></pre></div>


<p>Sets a constant <code>value</code> of <code>nc</code> components for the vertex attribute at
<code>pos</code> location.</p>
<h4>Function set_program_vertattr()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">set_program_vertattr</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">);</span>
</code></pre></div>


<p>Binds a buffer to a vertex attribute.</p>
<h4>Function set_program_vertattr()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">set_program_vertattr</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">def</span><span class="p">);</span>
</code></pre></div>


<p>Binds a buffer to a vertex attribute, or a constant value if the buffer is
empty.</p>
<h4>Function set_program_vertattr()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">set_program_vertattr</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">def</span><span class="p">);</span>
</code></pre></div>


<p>Binds a buffer or constant to a vertex attribute.</p>
<h4>Function set_program_vertattr()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">set_program_vertattr</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">var</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">def</span><span class="p">);</span>
</code></pre></div>


<p>Binds a buffer or constant to a vertex attribute.</p>
<h4>Function is_program_valid()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_program_valid</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">);</span>
</code></pre></div>


<p>Check whether the program is valid.</p>
<h4>Function bind_program()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">bind_program</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">);</span>
</code></pre></div>


<p>Binds a program.</p>
<h4>Function unbind_program()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">unbind_program</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">);</span>
</code></pre></div>


<p>Unbind a program.</p>
<p><a id="toc62"></a></p>
<h3>OpenGL default shaders</h3>
<h4>Struct gl_shape</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gl_shape</span> <span class="p">{</span>
</code></pre></div>


<p>Vertex buffers for scene drawing. Members are not part of the public API.</p>
<h4>Function clear_gl_shape()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">clear_gl_shape</span><span class="p">(</span><span class="n">gl_shape</span><span class="o">&amp;</span> <span class="n">shp</span><span class="p">);</span>
</code></pre></div>


<p>Clear shape.</p>
<h4>Function make_gl_lights()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">gl_lights</span> <span class="nf">make_gl_lights</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Initialize gl lights.</p>
<h4>Function make_gl_textures()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">texture</span><span class="o">*</span><span class="p">,</span> <span class="n">gl_texture</span><span class="o">&gt;</span> <span class="n">make_gl_textures</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Update scene textures on the GPU.</p>
<h4>Function make_gl_shapes()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">shape</span><span class="o">*</span><span class="p">,</span> <span class="n">gl_shape</span><span class="o">&gt;</span> <span class="n">make_gl_shapes</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Update scene shapes on the GPU.</p>
<h4>Function clear_gl_textures()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">clear_gl_textures</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">texture</span><span class="o">*</span><span class="p">,</span> <span class="n">gl_texture</span><span class="o">&gt;&amp;</span> <span class="n">textures</span><span class="p">);</span>
</code></pre></div>


<p>Clear scene textures on the GPU.</p>
<h4>Function clear_gl_shapes()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">clear_gl_shapes</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">shape</span><span class="o">*</span><span class="p">,</span> <span class="n">gl_shape</span><span class="o">&gt;&amp;</span> <span class="n">shapes</span><span class="p">);</span>
</code></pre></div>


<p>Clear scene shapes on the GPU.</p>
<h4>Function update_gl_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">update_gl_texture</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">texture</span><span class="o">*</span><span class="p">,</span> <span class="n">gl_texture</span><span class="o">&gt;&amp;</span> <span class="n">textures</span><span class="p">,</span> <span class="k">const</span> <span class="n">texture</span><span class="o">*</span> <span class="n">txt</span><span class="p">);</span>
</code></pre></div>


<p>Update scene textures on the GPU.</p>
<h4>Function update_gl_shape()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">update_gl_shape</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">shape</span><span class="o">*</span><span class="p">,</span> <span class="n">gl_shape</span><span class="o">&gt;&amp;</span> <span class="n">shapes</span><span class="p">,</span> <span class="k">const</span> <span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">);</span>
</code></pre></div>


<p>Update scene shapes on the GPU.</p>
<h4>Struct gl_stdimage_program</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gl_stdimage_program</span> <span class="p">{</span>
    <span class="n">gl_program</span> <span class="n">prog</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">gl_vertex_buffer</span> <span class="n">vbo</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>A shader for displaying images.  Members are not part of the public API.</p>
<ul>
<li>Members:<ul>
<li>prog:      Program.</li>
<li>vbo:      Vertex array.</li>
</ul>
</li>
</ul>
<h4>Function make_stdimage_program()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">gl_stdimage_program</span> <span class="nf">make_stdimage_program</span><span class="p">();</span>
</code></pre></div>


<p>Initialize a stdimage program.</p>
<h4>Function draw_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_image</span><span class="p">(</span><span class="n">gl_stdimage_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">win_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">float</span> <span class="n">zoom</span><span class="p">,</span> <span class="kt">float</span> <span class="n">exposure</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">gamma</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">filmic</span><span class="p">);</span>
</code></pre></div>


<p>Draws an image texture the stdimage program.</p>
<h4>Function draw_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">draw_image</span><span class="p">(</span><span class="n">gl_stdimage_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">win_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">float</span> <span class="n">zoom</span><span class="p">);</span>
</code></pre></div>


<p>Draws an image texture the stdimage program.</p>
<h4>Struct gl_stdimage_params</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gl_stdimage_params</span> <span class="p">{</span>
    <span class="n">vec2f</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="kt">float</span> <span class="n">zoom</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">exposure</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mf">2.2f</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">filmic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">vec4f</span> <span class="n">background</span> <span class="o">=</span> <span class="n">zero4f</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Params for stdimage drawing.</p>
<ul>
<li>Members:<ul>
<li>offset:      Image offset. </li>
<li>zoom:      Image zoom. </li>
<li>exposure:      Hdr exposure.  </li>
<li>gamma:      Hdr gamma.  </li>
<li>filmic:      Hdr filmic tonemapping. </li>
<li>background:      Image background. </li>
</ul>
</li>
</ul>
<h4>Function draw_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">draw_image</span><span class="p">(</span><span class="n">gl_stdimage_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">win_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_stdimage_params</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">clear_background</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Draws an image texture the stdimage program.</p>
<h4>Struct gl_stdsurface_program</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gl_stdsurface_program</span> <span class="p">{</span>
    <span class="n">gl_program</span> <span class="n">prog</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>Program to shade surfaces with a physically-based standard shader based on
Phong/GGX. Members are not part of public API.</p>
<ul>
<li>Members:<ul>
<li>prog:      Program.</li>
</ul>
</li>
</ul>
<h4>Function make_stdsurface_program()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">gl_stdsurface_program</span> <span class="nf">make_stdsurface_program</span><span class="p">();</span>
</code></pre></div>


<p>Initialize a stdsurface shader.</p>
<h4>Function is_program_valid()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_program_valid</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">);</span>
</code></pre></div>


<p>Check if the program is valid.</p>
<h4>Function begin_stdsurface_frame()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">begin_stdsurface_frame</span><span class="p">(</span><span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">shade_eyelight</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">tonemap_exposure</span><span class="p">,</span> <span class="kt">float</span> <span class="n">tonemap_gamma</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">tonemap_filmic</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">camera_xform</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">camera_xform_inv</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">camera_proj</span><span class="p">);</span>
</code></pre></div>


<p>Starts a frame by setting exposure/gamma values, camera transforms and
projection. Sets also whether to use full shading or a quick eye light
preview.</p>
<h4>Function end_stdsurface_frame()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">end_stdsurface_frame</span><span class="p">(</span><span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">);</span>
</code></pre></div>


<p>Ends a frame.</p>
<h4>Function set_stdsurface_lights()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">set_stdsurface_lights</span><span class="p">(</span>
    <span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">amb</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_lights</span><span class="o">&amp;</span> <span class="n">lights</span><span class="p">);</span>
</code></pre></div>


<p>Set shading lights and ambient.</p>
<h4>Function begin_stdsurface_shape()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">begin_stdsurface_shape</span><span class="p">(</span>
    <span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">xform</span><span class="p">,</span> <span class="kt">float</span> <span class="n">normal_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div>


<p>Begins drawing a shape with transform <code>xform</code>.</p>
<h4>Function end_stdsurface_shape()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">end_stdsurface_shape</span><span class="p">(</span><span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">);</span>
</code></pre></div>


<p>End shade drawing.</p>
<h4>Function set_stdsurface_normaloffset()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">set_stdsurface_normaloffset</span><span class="p">(</span>
    <span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">float</span> <span class="n">normal_offset</span><span class="p">);</span>
</code></pre></div>


<p>Sets normal offset.</p>
<h4>Function set_stdsurface_highlight()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">set_stdsurface_highlight</span><span class="p">(</span>
    <span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">highlight</span><span class="p">);</span>
</code></pre></div>


<p>Set the object as highlighted.</p>
<h4>Function set_stdsurface_material()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">set_stdsurface_material</span><span class="p">(</span><span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="n">material_type</span> <span class="n">type</span><span class="p">,</span>
    <span class="n">gl_elem_type</span> <span class="n">etype</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ke</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">kd</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ks</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">rs</span><span class="p">,</span> <span class="kt">float</span> <span class="n">op</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_texture_info</span><span class="o">&amp;</span> <span class="n">ke_txt</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_texture_info</span><span class="o">&amp;</span> <span class="n">kd_txt</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_texture_info</span><span class="o">&amp;</span> <span class="n">ks_txt</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_texture_info</span><span class="o">&amp;</span> <span class="n">rs_txt</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_texture_info</span><span class="o">&amp;</span> <span class="n">norm_txt</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_texture_info</span><span class="o">&amp;</span> <span class="n">occ_txt</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">use_phong</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">double_sided</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">alpha_cutout</span><span class="p">);</span>
</code></pre></div>


<p>Set material values with emission <code>ke</code>, diffuse <code>kd</code>, specular <code>ks</code> and
specular roughness <code>rs</code>, opacity <code>op</code>. Indicates textures ids with the
correspoinding <code>XXX_txt</code> variables. Sets also normal and occlusion
maps. Works for points/lines/triangles indicated by <code>etype</code>, (diffuse for
points, Kajiya-Kay for lines, GGX/Phong for triangles). Material <code>type</code>
matches the scene material type.</p>
<h4>Function set_stdsurface_constmaterial()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">set_stdsurface_constmaterial</span><span class="p">(</span>
    <span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ke</span><span class="p">,</span> <span class="kt">float</span> <span class="n">op</span><span class="p">);</span>
</code></pre></div>


<p>Set constant material with emission <code>ke</code> and opacity <code>op</code>.</p>
<h4>Function set_stdsurface_vert()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">set_stdsurface_vert</span><span class="p">(</span><span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">norm</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">texcoord</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">color</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">tangsp</span><span class="p">);</span>
</code></pre></div>


<p>Set vertex data with buffers for position pos, normals norm, texture
coordinates texcoord, per-vertex color color and tangent space tangsp.</p>
<h4>Function set_stdsurface_vert_skinning()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">set_stdsurface_vert_skinning</span><span class="p">(</span><span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">weights</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">joints</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">nxforms</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat4f</span><span class="o">*</span> <span class="n">xforms</span><span class="p">);</span>
</code></pre></div>


<p>Set vertex data with buffers for skinning.</p>
<h4>Function set_stdsurface_vert_gltf_skinning()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">set_stdsurface_vert_gltf_skinning</span><span class="p">(</span><span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">weights</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">joints</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">nxforms</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat4f</span><span class="o">*</span> <span class="n">xforms</span><span class="p">);</span>
</code></pre></div>


<p>Set vertex data with buffers for skinning.</p>
<h4>Function set_stdsurface_vert_skinning_off()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">set_stdsurface_vert_skinning_off</span><span class="p">(</span><span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">);</span>
</code></pre></div>


<p>Disables vertex skinning.</p>
<h4>Struct gl_stdsurface_params</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gl_stdsurface_params</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">resolution</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">exposure</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mf">2.2f</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">filmic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">wireframe</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">edges</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">edge_offset</span> <span class="o">=</span> <span class="mf">0.01f</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">cutout</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">eyelight</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">vec4f</span> <span class="n">background</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">ambient</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">highlight_color</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">edge_color</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="kt">bool</span> <span class="n">cull_backface</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Params for stdsurface drawing.</p>
<ul>
<li>Members:<ul>
<li>resolution:      Image resolution. </li>
<li>exposure:      Image exposure.  </li>
<li>gamma:      Image gamma.  </li>
<li>filmic:      Image filmic tonemapping. </li>
<li>wireframe:      Draw as wireframe.</li>
<li>edges:      Draw with overlaid edges</li>
<li>edge_offset:      Offset for edges. </li>
<li>cutout:      Draw with for binary transparency.</li>
<li>eyelight:      Camera light mode.</li>
<li>background:      Window background. </li>
<li>ambient:      Ambient illumination. </li>
<li>highlight_color:      Highlight color. </li>
<li>edge_color:      Edge color. </li>
<li>cull_backface:      Cull back face.</li>
</ul>
</li>
</ul>
<h4>Function draw_stdsurface_scene()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_stdsurface_scene</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">camera</span><span class="o">*</span> <span class="n">cam</span><span class="p">,</span>
    <span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">shape</span><span class="o">*</span><span class="p">,</span> <span class="n">gl_shape</span><span class="o">&gt;&amp;</span> <span class="n">shapes</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">texture</span><span class="o">*</span><span class="p">,</span> <span class="n">gl_texture</span><span class="o">&gt;&amp;</span> <span class="n">textures</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_lights</span><span class="o">&amp;</span> <span class="n">lights</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">viewport_size</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">highlighted</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_stdsurface_params</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">);</span>
</code></pre></div>


<p>Draw scene with stdsurface program.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">gl_stdimage_params</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<h4>Function visit()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">gl_stdsurface_params</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Visitor</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">);</span>
</code></pre></div>


<p>Visit struct elements.</p>
<p><a id="toc63"></a></p>
<h3>OpenGL window</h3>
<h4>Function void()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">gl_text_callback</span><span class="p">)(</span><span class="n">gl_window</span><span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
</code></pre></div>


<p>Text callback.</p>
<h4>Function void()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">gl_mouse_callback</span><span class="p">)(</span><span class="n">gl_window</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">button</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">press</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mods</span><span class="p">);</span>
</code></pre></div>


<p>Mouse callback.</p>
<h4>Function void()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">gl_refresh_callback</span><span class="p">)(</span><span class="n">gl_window</span><span class="o">*</span><span class="p">);</span>
</code></pre></div>


<p>Window refresh callback.</p>
<h4>Struct gl_window</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gl_window</span> <span class="p">{</span>
</code></pre></div>


<p>OpenGL window. Members are not part of the public API.</p>
<h4>Function make_window()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">gl_window</span><span class="o">*</span> <span class="nf">make_window</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">title</span><span class="p">,</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">user_pointer</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">);</span>
</code></pre></div>


<p>Initialize a window.</p>
<h4>Function set_window_callbacks()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">set_window_callbacks</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="n">gl_text_callback</span> <span class="n">text_cb</span><span class="p">,</span>
    <span class="n">gl_mouse_callback</span> <span class="n">mouse_cb</span><span class="p">,</span> <span class="n">gl_refresh_callback</span> <span class="n">refresh_cb</span><span class="p">);</span>
</code></pre></div>


<p>Set window callbacks.</p>
<h4>Function clear_window()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">clear_window</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Clear window.</p>
<h4>Function get_user_pointer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">get_user_pointer</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Gets the user poiner.</p>
<h4>Function set_window_title()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">set_window_title</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">title</span><span class="p">);</span>
</code></pre></div>


<p>Set window title.</p>
<h4>Function wait_events()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">wait_events</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Wait events</p>
<h4>Function poll_events()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">poll_events</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Poll events</p>
<h4>Function swap_buffers()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">swap_buffers</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Swap buffers</p>
<h4>Function should_close()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">should_close</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Should close</p>
<h4>Function get_window_size()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec2i</span> <span class="nf">get_window_size</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Window size</p>
<h4>Function get_framebuffer_size()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec2i</span> <span class="nf">get_framebuffer_size</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Framebuffer size</p>
<h4>Function get_mouse_button()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">int</span> <span class="nf">get_mouse_button</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Mouse button</p>
<h4>Function get_mouse_pos()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec2i</span> <span class="nf">get_mouse_pos</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Mouse position</p>
<h4>Function get_mouse_posf()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec2f</span> <span class="nf">get_mouse_posf</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Mouse position</p>
<h4>Function get_key()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">get_key</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">);</span>
</code></pre></div>


<p>Check if a key is pressed (not all keys are supported)</p>
<h4>Function get_screenshot()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4b</span><span class="o">&gt;</span> <span class="n">get_screenshot</span><span class="p">(</span>
    <span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">wh</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">flipy</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">back</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Read pixels</p>
<h4>Function save_screenshot()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_screenshot</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">imfilename</span><span class="p">);</span>
</code></pre></div>


<p>Save a screenshot to disk</p>
<h4>Function handle_camera_navigation()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">handle_camera_navigation</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="n">camera</span><span class="o">*</span> <span class="n">cam</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">navigation_fps</span><span class="p">);</span>
</code></pre></div>


<p>Handle camera navigation.</p>
<p><a id="toc64"></a></p>
<h3>OpenGL widgets</h3>
<h4>Function init_widgets()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">init_widgets</span><span class="p">(</span>
    <span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">light_style</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">extra_font</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Initialize widgets.</p>
<h4>Function begin_widgets()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">begin_widgets</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">title</span><span class="p">);</span>
</code></pre></div>


<p>Begin draw widgets.</p>
<h4>Function end_widgets()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">end_widgets</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>End draw widgets.</p>
<h4>Function get_widget_active()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">get_widget_active</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Whether widgets are active.</p>
<h4>Function draw_separator_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_separator_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Horizontal separator.</p>
<h4>Function draw_indent_widget_begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_indent_widget_begin</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Indent widget.</p>
<h4>Function draw_indent_widget_end()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_indent_widget_end</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Indent widget.</p>
<h4>Function draw_continue_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_continue_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Continue line with next widget.</p>
<h4>Function draw_label_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_label_widget</span><span class="p">(</span>
    <span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">);</span>
</code></pre></div>


<p>Label widget.</p>
<h4>Function draw_label_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">draw_label_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Label widget.</p>
<h4>Function draw_label_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">draw_label_widget</span><span class="p">(</span>
    <span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Label widget.</p>
<h4>Function draw_checkbox_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_checkbox_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Checkbox widget</p>
<h4>Function draw_text_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_text_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</code></pre></div>


<p>Text widget.</p>
<h4>Function draw_slider_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_slider_widget</span><span class="p">(</span>
    <span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Slider widget.</p>
<h4>Function draw_slider_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_slider_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Slider widget.</p>
<h4>Function draw_slider_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_slider_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Slider widget.</p>
<h4>Function draw_slider_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_slider_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Slider widget.</p>
<h4>Function draw_slider_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_slider_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Slider widget.</p>
<h4>Function draw_slider_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_slider_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Slider widget.</p>
<h4>Function draw_slider_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_slider_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Slider widget.</p>
<h4>Function draw_slider_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_slider_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Slider widget.</p>
<h4>Function draw_slider_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_slider_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span>
    <span class="n">mat</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Slider widget.</p>
<h4>Function draw_slider_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_slider_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span>
    <span class="n">frame</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">10</span><span class="p">);</span>
</code></pre></div>


<p>Slider widget.</p>
<h4>Function draw_slider_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_slider_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Slider widget.</p>
<h4>Function draw_color_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_color_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Color widget.</p>
<h4>Function draw_color_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_color_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">vec4b</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Color widget.</p>
<h4>Function draw_color_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_color_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Color widget.</p>
<h4>Function draw_combo_widget_begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_combo_widget_begin</span><span class="p">(</span>
    <span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">label</span><span class="p">);</span>
</code></pre></div>


<p>Combo widget.</p>
<h4>Function draw_combo_widget_item()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_combo_widget_item</span><span class="p">(</span>
    <span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">label</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">selected</span><span class="p">);</span>
</code></pre></div>


<p>Combo widget.</p>
<h4>Function draw_combo_widget_end()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_combo_widget_end</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Combo widget.</p>
<h4>Function draw_combo_widget_item()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">draw_combo_widget_item</span><span class="p">(</span>
    <span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">label</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">item</span><span class="p">);</span>
</code></pre></div>


<p>Combo widget.</p>
<h4>Function draw_combo_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">draw_combo_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;&amp;</span> <span class="n">vals</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">(</span><span class="k">const</span> <span class="n">T1</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;&amp;</span> <span class="n">value_func</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="k">const</span> <span class="n">T1</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;&amp;</span> <span class="n">label_func</span><span class="p">);</span>
</code></pre></div>


<p>Combo widget.</p>
<h4>Function draw_combo_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_combo_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">labels</span><span class="p">);</span>
</code></pre></div>


<p>Combo widget.</p>
<h4>Function draw_combo_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">draw_combo_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;&amp;</span> <span class="n">labels</span><span class="p">);</span>
</code></pre></div>


<p>Combo widget.</p>
<h4>Function draw_combo_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">draw_combo_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">T</span><span class="o">*&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;&amp;</span> <span class="n">vals</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">extra</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">extra_val</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">);</span>
</code></pre></div>


<p>Combo widget</p>
<h4>Function draw_button_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_button_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">);</span>
</code></pre></div>


<p>Button widget.</p>
<h4>Function draw_header_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_header_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">);</span>
</code></pre></div>


<p>Collapsible header widget.</p>
<h4>Function draw_tree_widget_begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_tree_widget_begin</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">);</span>
</code></pre></div>


<p>Start tree widget.</p>
<h4>Function draw_tree_widget_end()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_tree_widget_end</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>End tree widget.</p>
<h4>Function draw_tree_widget_begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_tree_widget_begin</span><span class="p">(</span>
    <span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="kt">void</span><span class="o">*&amp;</span> <span class="n">selection</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">content</span><span class="p">);</span>
</code></pre></div>


<p>Start selectable tree node widget.</p>
<h4>Function draw_tree_widget_begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_tree_widget_begin</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span>
    <span class="kt">void</span><span class="o">*&amp;</span> <span class="n">selection</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">content</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">col</span><span class="p">);</span>
</code></pre></div>


<p>Start selectable tree node widget.</p>
<h4>Function draw_tree_widget_end()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_tree_widget_end</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">content</span><span class="p">);</span>
</code></pre></div>


<p>End selectable tree node widget.</p>
<h4>Function draw_tree_widget_leaf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_tree_widget_leaf</span><span class="p">(</span>
    <span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="kt">void</span><span class="o">*&amp;</span> <span class="n">selection</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">content</span><span class="p">);</span>
</code></pre></div>


<p>Selectable tree leaf nodewidget.</p>
<h4>Function draw_tree_widget_leaf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_tree_widget_leaf</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span>
    <span class="kt">void</span><span class="o">*&amp;</span> <span class="n">selection</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">content</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">col</span><span class="p">);</span>
</code></pre></div>


<p>Selectable tree leaf node widget.</p>
<h4>Function draw_tree_widget_color_begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_tree_widget_color_begin</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">color</span><span class="p">);</span>
</code></pre></div>


<p>Text color widget.</p>
<h4>Function draw_tree_widget_color_end()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_tree_widget_color_end</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Text color widget.</p>
<h4>Function draw_image_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_image_widget</span><span class="p">(</span>
    <span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tid</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">imsize</span><span class="p">);</span>
</code></pre></div>


<p>Image widget.</p>
<h4>Function draw_image_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_image_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">size</span><span class="p">);</span>
</code></pre></div>


<p>Image widget.</p>
<h4>Function draw_scroll_widget_begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_scroll_widget_begin</span><span class="p">(</span>
    <span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">border</span><span class="p">);</span>
</code></pre></div>


<p>Scroll region widget.</p>
<h4>Function draw_scroll_widget_end()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_scroll_widget_end</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Scroll region widget.</p>
<h4>Function draw_scroll_widget_here()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_scroll_widget_here</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Scroll region widget.</p>
<h4>Function draw_groupid_widget_begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_groupid_widget_begin</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gid</span><span class="p">);</span>
</code></pre></div>


<p>Group ids widget.</p>
<h4>Function draw_groupid_widget_begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_groupid_widget_begin</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">gid</span><span class="p">);</span>
</code></pre></div>


<p>Group ids widget.</p>
<h4>Function draw_groupid_widget_begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_groupid_widget_begin</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">gid</span><span class="p">);</span>
</code></pre></div>


<p>Group ids widget.</p>
<h4>Function draw_groupid_widget_end()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_groupid_widget_end</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Group ids widget.</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">color</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Generic widget used for templated code. Min, max and color are ignored.</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">color</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Generic widget used for templated code. Min, max and color are ignored.</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">color</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Generic widget used for templated code. Uses min and max,
or a deafult range when their are the same. Color is ignored.</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span>
    <span class="n">vec</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">color</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Generic widget used for templated code. Uses min and max,
or a deafult range when their are the same. Color is ignored.</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span>
    <span class="kt">float</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">color</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Generic widget used for templated code. Uses min and max,
or a deafult range when their are the same. Color is ignored.</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span>
    <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">color</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Generic widget used for templated code. Uses min and max,
or a deafult range when their are the same. Color is ignored.</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span>
    <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">color</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Generic widget used for templated code. Uses min and max,
or a deafult range when their are the same.</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span>
    <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">color</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Generic widget used for templated code. Uses min and max,
or a deafult range when their are the same.</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span>
    <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">color</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Generic widget used for templated code. Uses min and max for frame origin,
or a deafult range when their are the same. Color is ignored.</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span>
    <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">color</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Generic widget used for templated code. Uses min and max,
or a deafult range when their are the same. Color is ignored.</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span>
    <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">color</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Generic widget used for templated code. Uses min and max,
or a deafult range when their are the same. Color is ignored.</p>
<h4>Constant int></h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
    <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_enum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">color</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
</code></pre></div>


<p>Generic widget used for templated code. Min, max and color are ignored.</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span>
    <span class="kt">uint32_t</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">color</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Generic widget used for templated code. Internally convert to int loosing
precision. See the int version.</p>
<h4>Function draw_imageinspect_widgets()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_imageinspect_widgets</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">hdr</span><span class="p">,</span> <span class="k">const</span> <span class="n">image4b</span><span class="o">&amp;</span> <span class="n">ldr</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">mouse_pos</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_stdimage_params</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">);</span>
</code></pre></div>


<p>Image inspection widgets.</p>
<h4>Function draw_params_widgets()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">draw_params_widgets</span><span class="p">(</span>
    <span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">);</span>
</code></pre></div>


<p>Draws a widget that sets params in non-recursive trivial structures.
Internally uses visit to implement the view.</p>
<h4>Function draw_camera_selection_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_camera_selection_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span>
    <span class="n">camera</span><span class="o">*&amp;</span> <span class="n">cam</span><span class="p">,</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="n">camera</span><span class="o">*</span> <span class="n">view</span><span class="p">);</span>
</code></pre></div>


<p>Draws a widget that can selected the camera.</p>
<h4>Function draw_camera_widgets()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_camera_widgets</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">camera</span><span class="o">*</span> <span class="n">cam</span><span class="p">);</span>
</code></pre></div>


<p>Draws widgets for a camera. Used for quickly making demos.</p>
<h4>Struct scene_selection</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">scene_selection</span> <span class="p">{</span>
    <span class="n">camera</span><span class="o">*</span> <span class="n">cam</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">shape_group</span><span class="o">*</span> <span class="n">sgr</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">shape</span><span class="o">*</span> <span class="n">shp</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">material</span><span class="o">*</span> <span class="n">mat</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">texture</span><span class="o">*</span> <span class="n">txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">instance</span><span class="o">*</span> <span class="n">ist</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">environment</span><span class="o">*</span> <span class="n">env</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">node</span><span class="o">*</span> <span class="n">nde</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">animation_group</span><span class="o">*</span> <span class="n">agr</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">animation</span><span class="o">*</span> <span class="n">anm</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Scene selection</p>
<ul>
<li>Members:<ul>
<li>cam:      Selected camera</li>
<li>sgr:      Selected shape group</li>
<li>shp:      Selected shape</li>
<li>mat:      Selected material</li>
<li>txt:      Selected texture</li>
<li>ist:      Selected instance</li>
<li>env:      Selected environment</li>
<li>nde:      Selected node</li>
<li>agr:      Selected animation group</li>
<li>anm:      Selected animation</li>
</ul>
</li>
</ul>
<h4>Function clear_selection()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_selection</span><span class="p">(</span><span class="n">scene_selection</span><span class="o">&amp;</span> <span class="n">sel</span><span class="p">);</span>
</code></pre></div>


<p>Clear selection</p>
<h4>Function get_untyped_selection()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">get_untyped_selection</span><span class="p">(</span><span class="n">scene_selection</span><span class="o">&amp;</span> <span class="n">sel</span><span class="p">);</span>
</code></pre></div>


<p>GVet untyped selection</p>
<h4>Function draw_scene_widgets()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_scene_widgets</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span>
    <span class="n">scene_selection</span><span class="o">&amp;</span> <span class="n">sel</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ygl</span><span class="o">::</span><span class="n">scene_selection</span><span class="o">&gt;&amp;</span> <span class="n">update_list</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">texture</span><span class="o">*</span><span class="p">,</span> <span class="n">gl_texture</span><span class="o">&gt;&amp;</span> <span class="n">gl_txt</span><span class="p">,</span>
    <span class="n">proc_scene</span><span class="o">*</span> <span class="n">test_scn</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">);</span>
</code></pre></div>


<p>Draws widgets for a whole scene. Used for quickly making demos.</p>
    <article>
    <footer></footer>
    </body>
    </html>
